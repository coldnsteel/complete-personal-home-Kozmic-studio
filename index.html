<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kozmic Pro Studio - SINWE Edition</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: linear-gradient(45deg, #1a1a2e, #16213e, #0f3460);
            color: white;
            overflow-x: auto;
            min-height: 100vh;
            animation: cosmicPulse 4s ease-in-out infinite alternate;
        }

        @keyframes cosmicPulse {
            0% { background: linear-gradient(45deg, #1a1a2e, #16213e, #0f3460); }
            100% { background: linear-gradient(45deg, #16213e, #0f3460, #1a1a2e); }
        }

        .container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 20px;
            padding: 20px;
            max-width: 1600px;
            margin: 0 auto;
        }

        .module {
            background: rgba(44, 44, 78, 0.9);
            border: 2px solid #ff6b9d;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 0 20px rgba(255, 107, 157, 0.3);
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
        }

        .module:hover {
            transform: translateY(-5px);
            box-shadow: 0 5px 30px rgba(255, 107, 157, 0.5);
        }

        .module h2 {
            text-align: center;
            margin-bottom: 20px;
            color: #ff6b9d;
            text-shadow: 0 0 10px rgba(255, 107, 157, 0.5);
            font-size: 1.5em;
        }

        .btn {
            background: linear-gradient(45deg, #ff6b9d, #4ecdc4);
            border: none;
            padding: 12px 20px;
            border-radius: 25px;
            color: white;
            cursor: pointer;
            font-weight: bold;
            margin: 5px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(255, 107, 157, 0.4);
        }

        .btn.active {
            background: linear-gradient(45deg, #4ade80, #64ffda);
            box-shadow: 0 0 15px rgba(74, 222, 128, 0.5);
        }

        .input-section {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        select {
            background: rgba(44, 44, 78, 0.8);
            color: white;
            border: 2px solid #ff6b9d;
            padding: 10px;
            border-radius: 10px;
            font-size: 14px;
        }

        .guitar-visual {
            position: relative;
            width: 100%;
            height: 200px;
            background: linear-gradient(45deg, #2c2c4e, #1a1a2e);
            border-radius: 10px;
            overflow: hidden;
            margin: 15px 0;
        }

        #videoFeed {
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: 10px;
            display: none;
        }

        #videoFeed.active {
            display: block;
        }

        #noVideoOverlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: #fff;
            font-size: 14px;
            z-index: 5;
        }

        .string {
            position: absolute;
            width: 2px;
            height: 100%;
            background: linear-gradient(to bottom, #ffd700, #ffed4e);
            box-shadow: 0 0 5px #ffd700;
        }

        .volume-meter {
            width: 100%;
            height: 20px;
            background: #2c2c4e;
            border-radius: 10px;
            overflow: hidden;
            margin: 10px 0;
        }

        .volume-bar {
            height: 100%;
            width: 0%;
            background: linear-gradient(to right, #4ecdc4, #ff6b9d);
            transition: width 0.1s ease;
        }

        .status-display {
            background: rgba(0,0,0,0.3);
            padding: 10px;
            border-radius: 10px;
            border-left: 4px solid #4ecdc4;
            font-family: monospace;
            font-size: 12px;
            margin-top: 10px;
        }

        .sinwe-mixer {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-top: 15px;
        }

        .mixer-section {
            background: rgba(0,0,0,0.2);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid #64ffda;
        }

        .mixer-section h4 {
            color: #64ffda;
            margin-bottom: 10px;
            font-size: 0.9rem;
        }

        .effects-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 8px;
            margin-top: 10px;
        }

        .effect-btn {
            background: rgba(44, 44, 78, 0.7);
            border: 1px solid #ff6b9d;
            color: #ff6b9d;
            padding: 8px 6px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 10px;
            text-align: center;
            transition: all 0.3s ease;
        }

        .effect-btn:hover, .effect-btn.active {
            background: #ff6b9d;
            color: #000;
            transform: translateY(-1px);
        }

        .slider-control {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 5px 0;
        }

        .slider-control label {
            color: #4ecdc4;
            font-size: 11px;
            min-width: 60px;
        }

        input[type="range"] {
            flex: 1;
            background: transparent;
            outline: none;
        }

        input[type="range"]::-webkit-slider-track {
            background: #2c2c4e;
            height: 6px;
            border-radius: 3px;
        }

        input[type="range"]::-webkit-slider-thumb {
            background: #ff6b9d;
            height: 16px;
            width: 16px;
            border-radius: 50%;
            cursor: pointer;
            -webkit-appearance: none;
            box-shadow: 0 0 5px rgba(255, 107, 157, 0.5);
        }

        .level-indicator {
            display: flex;
            gap: 2px;
            margin: 5px 0;
        }

        .level-bar {
            width: 4px;
            height: 20px;
            background: #2c2c4e;
            border-radius: 2px;
            transition: background 0.1s ease;
        }

        .level-bar.active-green { background: #4ade80; }
        .level-bar.active-yellow { background: #fcd34d; }
        .level-bar.active-red { background: #f87171; }

        .checklist-section {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .checklist-section label {
            display: flex;
            align-items: center;
            gap: 10px;
            cursor: pointer;
            padding: 8px;
            border-radius: 8px;
            transition: background 0.3s ease;
        }

        .checklist-section label:hover {
            background: rgba(255, 107, 157, 0.1);
        }

        .checklist-section input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: #ff6b9d;
        }

        #guitarStatus {
            font-weight: bold;
            padding: 8px;
            border-radius: 8px;
            text-align: center;
            margin-top: 10px;
            transition: all 0.3s ease;
        }

        .cosmic-creature {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 60px;
            height: 60px;
            background: radial-gradient(circle, #ff6b9d, #4ecdc4);
            border-radius: 50%;
            z-index: 1000;
            animation: float 3s ease-in-out infinite;
            cursor: pointer;
            box-shadow: 0 0 20px rgba(255, 107, 157, 0.5);
        }

        @keyframes float {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-10px); }
        }

        .pulse {
            animation: pulse 0.5s ease-in-out;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }

        .drum-pad {
            width: 50px;
            height: 50px;
            background: linear-gradient(45deg, #64ffda, #4ecdc4);
            border: 2px solid #ff6b9d;
            border-radius: 10px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
            transition: all 0.2s ease;
        }

        .drum-pad:hover {
            transform: scale(1.1);
            box-shadow: 0 0 15px rgba(100, 255, 218, 0.5);
        }

        .drum-pad.active {
            background: linear-gradient(45deg, #ff6b9d, #fcd34d);
        }

        .rhythm-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            margin-top: 15px;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- 1. Input Module -->
        <div class="module">
            <h2>üé§üé∏ Input Pod</h2>
            <div class="input-section">
                <select id="inputType">
                    <option value="guitar">Guitar Only üé∏</option>
                    <option value="mic">Mic Only üéôÔ∏è</option>
                    <option value="video">Video Only üì∑</option>
                    <option value="guitar-mic">Guitar + Mic üé∏üéôÔ∏è</option>
                    <option value="video-mic">Video + Mic üì∑üéôÔ∏è</option>
                </select>
                <button class="btn" id="connectInput">Connect Input</button>
                <button class="btn" id="recordAudioBtn">Record Audio üéô</button>
                <button class="btn" id="recordVideoBtn">Record Video üé•</button>
                
                <div class="guitar-visual" id="guitarVisual">
                    <video id="videoFeed" autoplay muted></video>
                    <div id="noVideoOverlay">
                        üé∏ Input Ready<br><small>Connect device to start</small>
                    </div>
                    <div class="string" style="left: 15%;"></div>
                    <div class="string" style="left: 25%;"></div>
                    <div class="string" style="left: 35%;"></div>
                    <div class="string" style="left: 45%;"></div>
                    <div class="string" style="left: 55%;"></div>
                    <div class="string" style="left: 65%;"></div>
                </div>
                
                <div class="volume-meter">
                    <div class="volume-bar" id="volumeBar"></div>
                </div>
                
                <div class="slider-control">
                    <label>Input Gain:</label>
                    <input type="range" id="inputGain" min="0" max="100" value="50">
                </div>
                
                <div class="status-display" id="inputStatus">Ready for inputs...<br>Click "Connect Input" to start!</div>
                <div id="guitarStatus">Guitar: Not Connected</div>
            </div>
        </div>

        <!-- 2. SINWE Mixer Module -->
        <div class="module">
            <h2>üéõÔ∏è SINWE Mixer</h2>
            <div class="input-section">
                <div class="sinwe-mixer">
                    <div class="mixer-section">
                        <h4>üéµ Recording Modes</h4>
                        <div class="effects-grid">
                            <div class="effect-btn" data-mode="primal">Primal</div>
                            <div class="effect-btn" data-mode="studio">Studio</div>
                            <div class="effect-btn" data-mode="pro">PRO</div>
                            <div class="effect-btn" data-mode="pop">POP</div>
                            <div class="effect-btn" data-mode="mc">MC</div>
                            <div class="effect-btn" data-mode="karaoke">Karaoke</div>
                            <div class="effect-btn" data-mode="lightning">Lightning</div>
                            <div class="effect-btn" data-mode="change">Change</div>
                        </div>
                    </div>
                    
                    <div class="mixer-section">
                        <h4>üîä Sound Effects</h4>
                        <div class="effects-grid">
                            <div class="effect-btn" data-effect="cheer">Cheer</div>
                            <div class="effect-btn" data-effect="din">Din</div>
                            <div class="effect-btn" data-effect="9277">9277</div>
                            <div class="effect-btn" data-effect="kiss">Kiss</div>
                            <div class="effect-btn" data-effect="gunshot">Gunshot</div>
                            <div class="effect-btn" data-effect="yell">Yell</div>
                            <div class="effect-btn" data-effect="laughter">Laughter</div>
                            <div class="effect-btn" data-effect="pubg">PUBG</div>
                            <div class="effect-btn" data-effect="dindin">Dindin</div>
                            <div class="effect-btn" data-effect="awesome">Awesome</div>
                            <div class="effect-btn" data-effect="giggle">Giggle</div>
                            <div class="effect-btn" data-effect="applause">Applause</div>
                            <div class="effect-btn" data-effect="slash">Slash</div>
                            <div class="effect-btn" data-effect="mary">Mary</div>
                            <div class="effect-btn" data-effect="awkward">Awkward</div>
                            <div class="effect-btn" data-effect="guys">Guys</div>
                        </div>
                    </div>
                </div>
                
                <div class="mixer-section">
                    <h4>üéöÔ∏è EQ Controls</h4>
                    <div class="slider-control">
                        <label>Treble:</label>
                        <input type="range" id="treble" min="0" max="100" value="50">
                        <span id="trebleValue">50%</span>
                    </div>
                    <div class="slider-control">
                        <label>Mid:</label>
                        <input type="range" id="mid" min="0" max="100" value="50">
                        <span id="midValue">50%</span>
                    </div>
                    <div class="slider-control">
                        <label>Bass:</label>
                        <input type="range" id="bass" min="0" max="100" value="50">
                        <span id="bassValue">50%</span>
                    </div>
                    <div class="slider-control">
                        <label>Echo:</label>
                        <input type="range" id="echo" min="0" max="100" value="0">
                        <span id="echoValue">0%</span>
                    </div>
                </div>
                
                <div class="mixer-section">
                    <h4>üìä Level Indicators</h4>
                    <div>Mic Level:</div>
                    <div class="level-indicator" id="micLevels">
                        <div class="level-bar"></div><div class="level-bar"></div><div class="level-bar"></div>
                        <div class="level-bar"></div><div class="level-bar"></div><div class="level-bar"></div>
                        <div class="level-bar"></div><div class="level-bar"></div><div class="level-bar"></div>
                        <div class="level-bar"></div>
                    </div>
                </div>
                
                <div class="sinwe-mixer">
                    <div class="mixer-section">
                        <h4>üîß Functions</h4>
                        <button class="btn" id="eliminationBtn">Elimination</button>
                        <button class="btn" id="muteBtn">Mute</button>
                        <button class="btn" id="denoiseBtn">Denoise</button>
                        <button class="btn" id="voiceOverBtn">Voice Over</button>
                    </div>
                    
                    <div class="mixer-section">
                        <h4>üì± Connectivity</h4>
                        <button class="btn" id="bluetoothBtn">Bluetooth</button>
                        <button class="btn" id="internalPlayBtn">Internal Play</button>
                        <div class="status-display" id="connectionStatus">USB-C Connected<br>Ready for 3-phone streaming</div>
                    </div>
                </div>
                
                <div class="status-display" id="mixerStatus">SINWE Mixer Ready - 44.1kHz/16-bit</div>
            </div>
        </div>

        <!-- 3. Rhythm & Beat Module -->
        <div class="module">
            <h2>ü•Å Rhythm & Beat</h2>
            <div class="input-section">
                <button class="btn" id="metronomeBtn">Metronome ‚è±Ô∏è</button>
                <button class="btn" id="tunerBtn">Guitar Tuner üéµ</button>
                
                <div class="slider-control">
                    <label>BPM:</label>
                    <input type="range" id="bpmSlider" min="60" max="200" value="120">
                    <span id="bpmDisplay">120</span>
                </div>
                
                <select id="timeSignature">
                    <option value="4/4">4/4</option>
                    <option value="3/4">3/4</option>
                    <option value="6/8">6/8</option>
                </select>
                
                <div class="rhythm-grid">
                    <div class="drum-pad" data-sound="kick">KICK</div>
                    <div class="drum-pad" data-sound="snare">SNARE</div>
                    <div class="drum-pad" data-sound="hat">HAT</div>
                    <div class="drum-pad" data-sound="crash">CRASH</div>
                    <div class="drum-pad" data-sound="ride">RIDE</div>
                    <div class="drum-pad" data-sound="tom">TOM</div>
                    <div class="drum-pad" data-sound="clap">CLAP</div>
                    <div class="drum-pad" data-sound="gallop">GALLOP</div>
                </div>
                
                <div class="status-display" id="rhythmStatus">Rhythm section ready!</div>
            </div>
        </div>

        <!-- 4. Streaming Module -->
        <div class="module">
            <h2>üé• Streaming</h2>
            <div class="input-section">
                <select id="streamPlatform">
                    <option value="youtube">YouTube</option>
                    <option value="twitch">Twitch</option>
                    <option value="custom">Custom RTMP</option>
                </select>
                
                <button class="btn" id="startStream">Start Stream üöÄ</button>
                
                <select id="streamQuality">
                    <option value="4k">4K Ultra HD</option>
                    <option value="1080p">1080p HD</option>
                    <option value="720p">720p</option>
                </select>
                
                <div class="status-display" id="streamStatus">Ready to stream...<br>Select platform and start!</div>
            </div>
        </div>

        <!-- 5. Master Controls -->
        <div class="module">
            <h2>üéöÔ∏è Master Controls</h2>
            <div class="input-section">
                <button class="btn" id="saveBtn">Save Session üíæ</button>
                <button class="btn" id="loadBtn">Load Session üìÇ</button>
                <button class="btn" id="exportBtn">Export Track üéß</button>
                
                <div class="slider-control">
                    <label>Master Volume:</label>
                    <input type="range" id="masterVolume" min="0" max="100" value="75">
                    <span id="masterVolumeValue">75%</span>
                </div>
                
                <button class="btn" id="jamBtn">Start Jam Session üé∏</button>
                <button class="btn" id="emergencyBtn">Emergency Stop üõë</button>
                
                <div class="status-display" id="masterStatus">Master controls active</div>
            </div>
        </div>

        <!-- 6. Equipment Checklist -->
        <div class="module">
            <h2>üîå Equipment Checklist</h2>
            <div class="checklist-section">
                <label><input type="checkbox" id="lightning-usbc"> Lightning-to-USB-C (iPhone 6S Plus)</label>
                <label><input type="checkbox" id="usbc-usbc"> USB-C-to-USB-C (iPhone 16 Pro Max)</label>
                <label><input type="checkbox" id="xlr-3.5mm"> XLR-to-3.5mm (UHF Mics)</label>
                <label><input type="checkbox" id="trs-1/4"> 1/4" TRS (Guitar Cable)</label>
                <label><input type="checkbox" id="hdmi-usbc"> HDMI-to-USB-C (4K Cam)</label>
                <label><input type="checkbox" id="sinwe-mixer"> SINWE Podcast Mixer</label>
                <label><input type="checkbox" id="condenser-mic"> SINWE Condenser Microphone</label>
                <label><input type="checkbox" id="tripod-stand"> Microphone Tripod Stand</label>
                
                <button class="btn" id="resetChecklistBtn">Reset Checklist üîÑ</button>
                <button class="btn" id="checkAllBtn">Check All Items ‚úÖ</button>
                
                <div class="status-display" id="checklistStatus">Check your SINWE equipment setup!</div>
            </div>
        </div>
    </div>

    <div class="cosmic-creature"></div>

    <script>
        // ===== KOZMIC PRO STUDIO - SINWE EDITION =====
        
        // Global Studio State
        const KozmicStudio = {
            // Audio System
            audioContext: null,
            guitarStream: null,
            videoStream: null,
            analyzer: null,
            dataArray: null,
            effectsChain: {},
            
            // SINWE Mixer State
            sinwe: {
                mode: 'primal',
                activeEffects: new Set(),
                eq: { treble: 50, mid: 50, bass: 50, echo: 0 },
                functions: { elimination: false, mute: false, denoise: false, voiceOver: false },
                connectivity: { bluetooth: false, internalPlay: false }
            },
            
            // Recording System
            isRecording: false,
            mediaRecorder: null,
            recordedChunks: [],
            
            // Rhythm System
            metronomeInterval: null,
            currentBPM: 120,
            isMetronomeActive: false,
            
            // Streaming System
            isStreaming: false,
            
            // Session State
            sessionActive: false
        };

        // Utility Functions
        function safeGetElement(id) {
            const element = document.getElementById(id);
            if (!element) {
                console.warn(`Element with id '${id}' not found`);
                return { 
                    style: {}, 
                    innerHTML: '', 
                    textContent: '', 
                    value: '',
                    classList: { add: () => {}, remove: () => {}, toggle: () => {} },
                    addEventListener: () => {}
                };
            }
            return element;
        }

        function log(message, type = 'info') {
            const timestamp = new Date().toLocaleTimeString();
            console.log(`[${timestamp}] KOZMIC: ${message}`);
            
            // Update relevant status displays
            if (type === 'mixer') {
                safeGetElement('mixerStatus').innerHTML = `SINWE: ${message}`;
            }
        }

        // Audio System Initialization
        function initAudio() {
            if (!KozmicStudio.audioContext) {
                try {
                    KozmicStudio.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    KozmicStudio.analyzer = KozmicStudio.audioContext.createAnalyser();
                    KozmicStudio.analyzer.fftSize = 256;
                    KozmicStudio.dataArray = new Uint8Array(KozmicStudio.analyzer.frequencyBinCount);
                    log('Audio context initialized successfully');
                } catch (e) {
                    log('Audio context initialization failed: ' + e.message, 'error');
                }
            }
        }

        // Input Connection System
        async function connectInput() {
            try {
                initAudio();
                const inputType = safeGetElement('inputType').value;
                const inputStatus = safeGetElement('inputStatus');
                
                // Reset previous streams
                if (KozmicStudio.guitarStream) {
                    KozmicStudio.guitarStream.getTracks().forEach(track => track.stop());
                    KozmicStudio.guitarStream = null;
                }
                if (KozmicStudio.videoStream) {
                    KozmicStudio.videoStream.getTracks().forEach(track => track.stop());
                    KozmicStudio.videoStream = null;
                }

                inputStatus.innerHTML = 'Connecting to SINWE system...';

                // Audio input constraints optimized for SINWE mixer
                const audioConstraints = { 
                    echoCancellation: false, 
                    noiseSuppression: false, 
                    autoGainControl: false,
                    sampleRate: 44100,
                    channelCount: 1
                };
                
                // Handle audio inputs
                if (inputType.includes('guitar') || inputType.includes('mic')) {
                    try {
                        KozmicStudio.guitarStream = await navigator.mediaDevices.getUserMedia({ audio: audioConstraints });
                        setupSINWEEffectsChain();
                        startVolumeMonitoring();
                        startLevelIndicators();
                        
                        inputStatus.innerHTML = 'üé∏ SINWE Audio Connected!<br>44.1kHz/16-bit Active';
                        log('SINWE audio input connected');
                    } catch (e) {
                        inputStatus.innerHTML = '‚ùå Audio Error: ' + e.message;
                        log('Audio connection failed: ' + e.message, 'error');
                    }
                }

                // Handle video input
                if (inputType.includes('video')) {
                    try {
                        const videoConstraints = { 
                            width: { ideal: 1920, max: 1920 }, 
                            height: { ideal: 1080, max: 1080 },
                            frameRate: { ideal: 30 }
                        };
                        
                        KozmicStudio.videoStream = await navigator.mediaDevices.getUserMedia({ 
                            video: videoConstraints, 
                            audio: false 
                        });
                        
                        const videoFeed = safeGetElement('videoFeed');
                        const noVideoOverlay = safeGetElement('noVideoOverlay');
                        
                        if (videoFeed && KozmicStudio.videoStream) {
                            videoFeed.srcObject = KozmicStudio.videoStream;
                            videoFeed.classList.add('active');
                            noVideoOverlay.style.display = 'none';
                            inputStatus.innerHTML += '<br>üì∑ Video Active!';
                        }
                    } catch (e) {
                        inputStatus.innerHTML += '<br>‚ùå Video Error: ' + e.message;
                        log('Video connection failed: ' + e.message, 'error');
                    }
                }

                pulseCreature();
                
            } catch (e) {
                log('Input connection error: ' + e.message, 'error');
                safeGetElement('inputStatus').innerHTML = '‚ùå Connection Error: ' + e.message;
            }
        }

        // SINWE Effects Chain Setup
        function setupSINWEEffectsChain() {
            if (!KozmicStudio.audioContext || !KozmicStudio.guitarStream) return;
            
            try {
                const source = KozmicStudio.audioContext.createMediaStreamSource(KozmicStudio.guitarStream);
                
                // Create SINWE-specific effects chain
                KozmicStudio.effectsChain = {
                    inputGain: KozmicStudio.audioContext.createGain(),
                    trebleFilter: KozmicStudio.audioContext.createBiquadFilter(),
                    midFilter: KozmicStudio.audioContext.createBiquadFilter(),
                    bassFilter: KozmicStudio.audioContext.createBiquadFilter(),
                    echoDelay: KozmicStudio.audioContext.createDelay(2.0),
                    echoGain: KozmicStudio.audioContext.createGain(),
                    outputGain: KozmicStudio.audioContext.createGain()
                };

                // Configure EQ filters to match SINWE specs
                KozmicStudio.effectsChain.trebleFilter.type = 'highshelf';
                KozmicStudio.effectsChain.trebleFilter.frequency.setValueAtTime(8000, KozmicStudio.audioContext.currentTime);
                
                KozmicStudio.effectsChain.midFilter.type = 'peaking';
                KozmicStudio.effectsChain.midFilter.frequency.setValueAtTime(1000, KozmicStudio.audioContext.currentTime);
                KozmicStudio.effectsChain.midFilter.Q.setValueAtTime(1, KozmicStudio.audioContext.currentTime);
                
                KozmicStudio.effectsChain.bassFilter.type = 'lowshelf';
                KozmicStudio.effectsChain.bassFilter.frequency.setValueAtTime(200, KozmicStudio.audioContext.currentTime);

                // Connect the SINWE chain
                source.connect(KozmicStudio.effectsChain.inputGain);
                KozmicStudio.effectsChain.inputGain.connect(KozmicStudio.analyzer);
                KozmicStudio.effectsChain.inputGain.connect(KozmicStudio.effectsChain.trebleFilter);
                KozmicStudio.effectsChain.trebleFilter.connect(KozmicStudio.effectsChain.midFilter);
                KozmicStudio.effectsChain.midFilter.connect(KozmicStudio.effectsChain.bassFilter);
                KozmicStudio.effectsChain.bassFilter.connect(KozmicStudio.effectsChain.echoDelay);
                KozmicStudio.effectsChain.echoDelay.connect(KozmicStudio.effectsChain.echoGain);
                KozmicStudio.effectsChain.echoGain.connect(KozmicStudio.effectsChain.outputGain);
                KozmicStudio.effectsChain.bassFilter.connect(KozmicStudio.effectsChain.outputGain);
                KozmicStudio.effectsChain.outputGain.connect(KozmicStudio.audioContext.destination);

                // Set initial SINWE values
                KozmicStudio.effectsChain.inputGain.gain.setValueAtTime(0.5, KozmicStudio.audioContext.currentTime);
                KozmicStudio.effectsChain.outputGain.gain.setValueAtTime(0.75, KozmicStudio.audioContext.currentTime);
                KozmicStudio.effectsChain.echoDelay.delayTime.setValueAtTime(0.3, KozmicStudio.audioContext.currentTime);
                KozmicStudio.effectsChain.echoGain.gain.setValueAtTime(0, KozmicStudio.audioContext.currentTime);
                
                log('SINWE effects chain initialized', 'mixer');
            } catch (e) {
                log('SINWE effects chain setup failed: ' + e.message, 'error');
            }
        }

        // Volume and Level Monitoring
        function startVolumeMonitoring() {
            if (!KozmicStudio.analyzer || !KozmicStudio.dataArray) return;
            
            function updateVolume() {
                try {
                    KozmicStudio.analyzer.getByteFrequencyData(KozmicStudio.dataArray);
                    const sum = KozmicStudio.dataArray.reduce((a, b) => a + b, 0);
                    const average = sum / KozmicStudio.dataArray.length;
                    const volumePercentage = Math.min((average / 128) * 100, 100);
                    
                    const volumeBar = safeGetElement('volumeBar');
                    volumeBar.style.width = volumePercentage + '%';
                    
                    // Update guitar status based on signal
                    const guitarStatus = safeGetElement('guitarStatus');
                    if (average > 10) {
                        guitarStatus.textContent = 'SINWE: Signal Active üé∏';
                        guitarStatus.style.color = '#4ade80';
                        guitarStatus.style.background = 'rgba(74, 222, 128, 0.2)';
                    } else {
                        guitarStatus.textContent = 'SINWE: Standby';
                        guitarStatus.style.color = '#fcd34d';
                        guitarStatus.style.background = 'rgba(252, 211, 77, 0.2)';
                    }
                    
                    requestAnimationFrame(updateVolume);
                } catch (e) {
                    log('Volume monitoring error: ' + e.message, 'error');
                }
            }
            updateVolume();
        }

        // SINWE Level Indicators
        function startLevelIndicators() {
            function updateLevels() {
                if (!KozmicStudio.analyzer || !KozmicStudio.dataArray) return;
                
                try {
                    KozmicStudio.analyzer.getByteFrequencyData(KozmicStudio.dataArray);
                    const micLevels = safeGetElement('micLevels');
                    const levelBars = micLevels.querySelectorAll('.level-bar');
                    
                    const sum = KozmicStudio.dataArray.reduce((a, b) => a + b, 0);
                    const average = sum / KozmicStudio.dataArray.length;
                    const levelCount = Math.floor((average / 128) * 10);
                    
                    levelBars.forEach((bar, index) => {
                        bar.className = 'level-bar';
                        if (index < levelCount) {
                            if (index < 6) bar.classList.add('active-green');
                            else if (index < 8) bar.classList.add('active-yellow');
                            else bar.classList.add('active-red');
                        }
                    });
                    
                    requestAnimationFrame(updateLevels);
                } catch (e) {
                    log('Level indicator error: ' + e.message, 'error');
                }
            }
            updateLevels();
        }

        // SINWE Recording Mode Management
        function setSINWEMode(mode) {
            KozmicStudio.sinwe.mode = mode;
            
            // Update UI
            document.querySelectorAll('[data-mode]').forEach(btn => {
                btn.classList.remove('active');
                if (btn.dataset.mode === mode) {
                    btn.classList.add('active');
                }
            });
            
            // Apply mode-specific settings
            const modeSettings = {
                primal: { treble: 50, mid: 50, bass: 50 },
                studio: { treble: 60, mid: 55, bass: 45 },
                pro: { treble: 65, mid: 60, bass: 50 },
                pop: { treble: 70, mid: 65, bass: 40 },
                mc: { treble: 75, mid: 70, bass: 35 },
                karaoke: { treble: 60, mid: 70, bass: 60 },
                lightning: { treble: 80, mid: 50, bass: 30 },
                change: { treble: 55, mid: 45, bass: 65 }
            };
            
            if (modeSettings[mode]) {
                const settings = modeSettings[mode];
                updateEQ('treble', settings.treble);
                updateEQ('mid', settings.mid);
                updateEQ('bass', settings.bass);
            }
            
            log(`Recording mode: ${mode.toUpperCase()}`, 'mixer');
        }

        // SINWE Sound Effects Trigger
        function triggerSINWEEffect(effect) {
            if (KozmicStudio.sinwe.activeEffects.has(effect)) {
                KozmicStudio.sinwe.activeEffects.delete(effect);
                document.querySelector(`[data-effect="${effect}"]`).classList.remove('active');
                log(`Effect ${effect} OFF`, 'mixer');
            } else {
                KozmicStudio.sinwe.activeEffects.add(effect);
                document.querySelector(`[data-effect="${effect}"]`).classList.add('active');
                
                // Simulate effect trigger
                if (KozmicStudio.audioContext) {
                    const oscillator = KozmicStudio.audioContext.createOscillator();
                    const gainNode = KozmicStudio.audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(KozmicStudio.audioContext.destination);
                    
                    // Effect-specific frequencies
                    const effectFreqs = {
                        cheer: 800, din: 400, gunshot: 100, laughter: 600,
                        applause: 1000, awesome: 750, pubg: 200
                    };
                    
                    oscillator.frequency.value = effectFreqs[effect] || 500;
                    gainNode.gain.setValueAtTime(0.1, KozmicStudio.audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, KozmicStudio.audioContext.currentTime + 0.5);
                    
                    oscillator.start(KozmicStudio.audioContext.currentTime);
                    oscillator.stop(KozmicStudio.audioContext.currentTime + 0.5);
                }
                
                log(`Effect ${effect} triggered!`, 'mixer');
                
                // Auto-deactivate after 2 seconds
                setTimeout(() => {
                    KozmicStudio.sinwe.activeEffects.delete(effect);
                    document.querySelector(`[data-effect="${effect}"]`).classList.remove('active');
                }, 2000);
            }
            
            pulseCreature();
        }

        // EQ Control System
        function updateEQ(band, value) {
            KozmicStudio.sinwe.eq[band] = value;
            
            // Update slider and display
            const slider = safeGetElement(band);
            const display = safeGetElement(band + 'Value');
            slider.value = value;
            display.textContent = value + '%';
            
            // Apply to audio chain
            if (KozmicStudio.effectsChain && KozmicStudio.audioContext) {
                const currentTime = KozmicStudio.audioContext.currentTime;
                const gainValue = (value - 50) / 50 * 12; // Convert to dB range
                
                try {
                    switch(band) {
                        case 'treble':
                            KozmicStudio.effectsChain.trebleFilter.gain.setValueAtTime(gainValue, currentTime);
                            break;
                        case 'mid':
                            KozmicStudio.effectsChain.midFilter.gain.setValueAtTime(gainValue, currentTime);
                            break;
                        case 'bass':
                            KozmicStudio.effectsChain.bassFilter.gain.setValueAtTime(gainValue, currentTime);
                            break;
                        case 'echo':
                            const echoAmount = value / 100 * 0.3;
                            KozmicStudio.effectsChain.echoGain.gain.setValueAtTime(echoAmount, currentTime);
                            break;
                    }
                } catch (e) {
                    log(`EQ update error for ${band}: ${e.message}`, 'error');
                }
            }
        }

        // SINWE Function Controls
        function toggleSINWEFunction(func) {
            KozmicStudio.sinwe.functions[func] = !KozmicStudio.sinwe.functions[func];
            const button = safeGetElement(func + 'Btn');
            
            if (KozmicStudio.sinwe.functions[func]) {
                button.classList.add('active');
                log(`${func} ON`, 'mixer');
            } else {
                button.classList.remove('active');
                log(`${func} OFF`, 'mixer');
            }
            
            // Apply function logic
            if (KozmicStudio.effectsChain && KozmicStudio.audioContext) {
                const currentTime = KozmicStudio.audioContext.currentTime;
                
                switch(func) {
                    case 'mute':
                        const muteGain = KozmicStudio.sinwe.functions[func] ? 0 : 0.75;
                        KozmicStudio.effectsChain.outputGain.gain.setValueAtTime(muteGain, currentTime);
                        break;
                    case 'elimination':
                        // Implement noise gate or similar
                        break;
                    case 'denoise':
                        // Implement noise reduction
                        break;
                    case 'voiceOver':
                        // Implement voice-over ducking
                        break;
                }
            }
        }

        // Recording System
        function toggleRecording(type) {
            try {
                if (!KozmicStudio.isRecording) {
                    startRecording(type);
                } else {
                    stopRecording();
                }
            } catch (e) {
                log(`Recording error: ${e.message}`, 'error');
            }
        }

        function startRecording(type) {
            try {
                if (!KozmicStudio.guitarStream && !KozmicStudio.videoStream) {
                    log('No input stream available for recording', 'error');
                    return;
                }

                KozmicStudio.recordedChunks = [];
                let streamToRecord;
                
                if (type === 'video' && KozmicStudio.videoStream && KozmicStudio.guitarStream) {
                    streamToRecord = new MediaStream([
                        ...KozmicStudio.videoStream.getVideoTracks(),
                        ...KozmicStudio.guitarStream.getAudioTracks()
                    ]);
                } else if (type === 'video' && KozmicStudio.videoStream) {
                    streamToRecord = KozmicStudio.videoStream;
                } else if (KozmicStudio.guitarStream) {
                    streamToRecord = KozmicStudio.guitarStream;
                } else {
                    throw new Error('No suitable stream for recording');
                }

                KozmicStudio.mediaRecorder = new MediaRecorder(streamToRecord);
                
                KozmicStudio.mediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        KozmicStudio.recordedChunks.push(event.data);
                    }
                };

                KozmicStudio.mediaRecorder.onstop = () => {
                    const blob = new Blob(KozmicStudio.recordedChunks, { 
                        type: type === 'video' ? 'video/webm' : 'audio/webm' 
                    });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `sinwe_${type}_${Date.now()}.webm`;
                    a.click();
                    URL.revokeObjectURL(url);
                    log(`${type} recording saved!`);
                };

                KozmicStudio.mediaRecorder.start();
                KozmicStudio.isRecording = true;
                
                const recordBtn = safeGetElement(type === 'video' ? 'recordVideoBtn' : 'recordAudioBtn');
                recordBtn.textContent = `Stop ${type} üõë`;
                recordBtn.classList.add('active');
                
                log(`${type} recording started`);
                
            } catch (e) {
                log(`Recording start error: ${e.message}`, 'error');
            }
        }

        function stopRecording() {
            try {
                if (KozmicStudio.mediaRecorder && KozmicStudio.isRecording) {
                    KozmicStudio.mediaRecorder.stop();
                    KozmicStudio.isRecording = false;
                    
                    safeGetElement('recordAudioBtn').textContent = 'Record Audio üéô';
                    safeGetElement('recordVideoBtn').textContent = 'Record Video üé•';
                    safeGetElement('recordAudioBtn').classList.remove('active');
                    safeGetElement('recordVideoBtn').classList.remove('active');
                    
                    log('Recording stopped');
                }
            } catch (e) {
                log(`Recording stop error: ${e.message}`, 'error');
            }
        }

        // Rhythm System
        function toggleMetronome() {
            if (KozmicStudio.isMetronomeActive) {
                stopMetronome();
            } else {
                startMetronome();
            }
        }

        function startMetronome() {
            if (KozmicStudio.metronomeInterval) return;
            
            try {
                const interval = 60000 / KozmicStudio.currentBPM;
                KozmicStudio.metronomeInterval = setInterval(() => {
                    if (KozmicStudio.audioContext) {
                        const oscillator = KozmicStudio.audioContext.createOscillator();
                        const gainNode = KozmicStudio.audioContext.createGain();
                        
                        oscillator.connect(gainNode);
                        gainNode.connect(KozmicStudio.audioContext.destination);
                        
                        oscillator.frequency.value = 800;
                        gainNode.gain.setValueAtTime(0.1, KozmicStudio.audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, KozmicStudio.audioContext.currentTime + 0.1);
                        
                        oscillator.start(KozmicStudio.audioContext.currentTime);
                        oscillator.stop(KozmicStudio.audioContext.currentTime + 0.1);
                    }
                    pulseCreature();
                }, interval);

                KozmicStudio.isMetronomeActive = true;
                safeGetElement('metronomeBtn').classList.add('active');
                safeGetElement('rhythmStatus').innerHTML = `Metronome: ${KozmicStudio.currentBPM} BPM ACTIVE`;
                log(`Metronome started at ${KozmicStudio.currentBPM} BPM`);
            } catch (e) {
                log(`Metronome error: ${e.message}`, 'error');
            }
        }

        function stopMetronome() {
            if (KozmicStudio.metronomeInterval) {
                clearInterval(KozmicStudio.metronomeInterval);
                KozmicStudio.metronomeInterval = null;
                KozmicStudio.isMetronomeActive = false;
                safeGetElement('metronomeBtn').classList.remove('active');
                safeGetElement('rhythmStatus').innerHTML = 'Metronome: STOPPED';
                log('Metronome stopped');
            }
        }

        function setBPM(value) {
            KozmicStudio.currentBPM = parseInt(value);
            safeGetElement('bpmDisplay').textContent = KozmicStudio.currentBPM;
            
            // Restart metronome if active
            if (KozmicStudio.isMetronomeActive) {
                stopMetronome();
                startMetronome();
            }
        }

        // Drum Pad System
        function triggerDrumSound(sound) {
            if (!KozmicStudio.audioContext) return;
            
            try {
                const oscillator = KozmicStudio.audioContext.createOscillator();
                const gainNode = KozmicStudio.audioContext.createGain();
                const filter = KozmicStudio.audioContext.createBiquadFilter();
                
                oscillator.connect(filter);
                filter.connect(gainNode);
                gainNode.connect(KozmicStudio.audioContext.destination);
                
                // Sound-specific parameters
                const drumSounds = {
                    kick: { freq: 60, type: 'sawtooth', decay: 0.5 },
                    snare: { freq: 200, type: 'square', decay: 0.2 },
                    hat: { freq: 8000, type: 'square', decay: 0.1 },
                    crash: { freq: 4000, type: 'sawtooth', decay: 1.0 },
                    ride: { freq: 3000, type: 'triangle', decay: 0.8 },
                    tom: { freq: 150, type: 'sawtooth', decay: 0.4 },
                    clap: { freq: 1000, type: 'square', decay: 0.15 },
                    gallop: { freq: 80, type: 'sawtooth', decay: 0.3 }
                };
                
                const drumParams = drumSounds[sound] || drumSounds.kick;
                
                oscillator.type = drumParams.type;
                oscillator.frequency.setValueAtTime(drumParams.freq, KozmicStudio.audioContext.currentTime);
                filter.frequency.setValueAtTime(drumParams.freq * 2, KozmicStudio.audioContext.currentTime);
                gainNode.gain.setValueAtTime(0.3, KozmicStudio.audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, KozmicStudio.audioContext.currentTime + drumParams.decay);
                
                oscillator.start(KozmicStudio.audioContext.currentTime);
                oscillator.stop(KozmicStudio.audioContext.currentTime + drumParams.decay);
                
                // Visual feedback
                const drumPad = document.querySelector(`[data-sound="${sound}"]`);
                if (drumPad) {
                    drumPad.classList.add('active');
                    setTimeout(() => drumPad.classList.remove('active'), 100);
                }
                
                log(`Drum sound: ${sound.toUpperCase()}`);
            } catch (e) {
                log(`Drum sound error: ${e.message}`, 'error');
            }
        }

        // Streaming System
        function toggleStreaming() {
            if (KozmicStudio.isStreaming) {
                stopStreaming();
            } else {
                startStreaming();
            }
        }

        function startStreaming() {
            try {
                if (!KozmicStudio.guitarStream && !KozmicStudio.videoStream) {
                    log('No input streams for streaming', 'error');
                    return;
                }

                const platform = safeGetElement('streamPlatform').value;
                const quality = safeGetElement('streamQuality').value;
                
                KozmicStudio.isStreaming = true;
                safeGetElement('startStream').textContent = 'Stop Stream ‚èπÔ∏è';
                safeGetElement('startStream').classList.add('active');
                safeGetElement('streamStatus').innerHTML = `üì° LIVE on ${platform.toUpperCase()}<br>Quality: ${quality}<br>SINWE Audio Active`;
                
                log(`Streaming started: ${platform} (${quality})`);
                pulseCreature();
            } catch (e) {
                log(`Streaming error: ${e.message}`, 'error');
            }
        }

        function stopStreaming() {
            KozmicStudio.isStreaming = false;
            safeGetElement('startStream').textContent = 'Start Stream üöÄ';
            safeGetElement('startStream').classList.remove('active');
            safeGetElement('streamStatus').innerHTML = 'Stream stopped<br>Ready to stream again';
            log('Streaming stopped');
        }

        // Session Management
        function saveSession() {
            try {
                const sessionData = {
                    timestamp: Date.now(),
                    sinwe: KozmicStudio.sinwe,
                    bpm: KozmicStudio.currentBPM,
                    version: 'SINWE Edition'
                };
                
                const blob = new Blob([JSON.stringify(sessionData, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `sinwe_session_${Date.now()}.json`;
                a.click();
                URL.revokeObjectURL(url);
                
                log('Session saved successfully');
                safeGetElement('masterStatus').innerHTML = 'Session saved! üíæ';
            } catch (e) {
                log(`Save session error: ${e.message}`, 'error');
            }
        }

        function loadSession() {
            try {
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = '.json';
                
                input.onchange = (e) => {
                    const file = e.target.files[0];
                    if (!file) return;

                    const reader = new FileReader();
                    reader.onload = (e) => {
                        try {
                            const sessionData = JSON.parse(e.target.result);
                            
                            // Restore SINWE settings
                            if (sessionData.sinwe) {
                                KozmicStudio.sinwe = sessionData.sinwe;
                                
                                // Update UI
                                Object.keys(KozmicStudio.sinwe.eq).forEach(band => {
                                    updateEQ(band, KozmicStudio.sinwe.eq[band]);
                                });
                                
                                setSINWEMode(KozmicStudio.sinwe.mode);
                            }
                            
                            // Restore BPM
                            if (sessionData.bpm) {
                                setBPM(sessionData.bpm);
                                safeGetElement('bpmSlider').value = sessionData.bpm;
                            }
                            
                            log('Session loaded successfully');
                            safeGetElement('masterStatus').innerHTML = 'Session loaded! üìÇ';
                        } catch (e) {
                            log(`Load session error: ${e.message}`, 'error');
                        }
                    };
                    reader.readAsText(file);
                };
                
                input.click();
            } catch (e) {
                log(`Load session error: ${e.message}`, 'error');
            }
        }

        function emergencyStop() {
            try {
                // Stop all streams
                if (KozmicStudio.guitarStream) {
                    KozmicStudio.guitarStream.getTracks().forEach(track => track.stop());
                    KozmicStudio.guitarStream = null;
                }
                if (KozmicStudio.videoStream) {
                    KozmicStudio.videoStream.getTracks().forEach(track => track.stop());
                    KozmicStudio.videoStream = null;
                }
                
                // Stop recording and streaming
                if (KozmicStudio.isRecording) stopRecording();
                if (KozmicStudio.isStreaming) stopStreaming();
                if (KozmicStudio.isMetronomeActive) stopMetronome();
                
                // Reset SINWE state
                KozmicStudio.sinwe.activeEffects.clear();
                Object.keys(KozmicStudio.sinwe.functions).forEach(func => {
                    KozmicStudio.sinwe.functions[func] = false;
                    safeGetElement(func + 'Btn').classList.remove('active');
                });
                
                // Reset UI
                document.querySelectorAll('.btn.active').forEach(btn => btn.classList.remove('active'));
                document.querySelectorAll('.effect-btn.active').forEach(btn => btn.classList.remove('active'));
                
                // Update status displays
                safeGetElement('inputStatus').innerHTML = 'EMERGENCY STOP - All systems halted';
                safeGetElement('mixerStatus').innerHTML = 'SINWE: System Reset';
                safeGetElement('streamStatus').innerHTML = 'Streaming stopped';
                safeGetElement('rhythmStatus').innerHTML = 'Rhythm: Stopped';
                safeGetElement('masterStatus').innerHTML = 'EMERGENCY STOP COMPLETE';
                safeGetElement('guitarStatus').textContent = 'SINWE: Disconnected';
                
                log('EMERGENCY STOP executed - all systems reset');
            } catch (e) {
                log(`Emergency stop error: ${e.message}`, 'error');
            }
        }

        // Equipment Checklist
        function resetChecklist() {
            try {
                document.querySelectorAll('input[type="checkbox"]').forEach(checkbox => {
                    checkbox.checked = false;
                });
                safeGetElement('checklistStatus').innerHTML = 'Checklist reset! Check your SINWE equipment setup.';
                log('Equipment checklist reset');
            } catch (e) {
                log(`Checklist reset error: ${e.message}`, 'error');
            }
        }

        function checkAllItems() {
            try {
                document.querySelectorAll('input[type="checkbox"]').forEach(checkbox => {
                    checkbox.checked = true;
                });
                safeGetElement('checklistStatus').innerHTML = '‚úÖ All SINWE equipment checked! Ready to rock!';
                log('All equipment items checked');
                pulseCreature();
            } catch (e) {
                log(`Check all items error: ${e.message}`, 'error');
            }
        }

        // Cosmic Creature Animation
        function pulseCreature() {
            try {
                const creature = document.querySelector('.cosmic-creature');
                if (creature) {
                    creature.classList.add('pulse');
                    setTimeout(() => creature.classList.remove('pulse'), 500);
                }
            } catch (e) {
                log(`Creature animation error: ${e.message}`, 'error');
            }
        }

        // Event Listeners Setup
        function setupEventListeners() {
            try {
                // Input Controls
                safeGetElement('connectInput').addEventListener('click', connectInput);
                safeGetElement('recordAudioBtn').addEventListener('click', () => toggleRecording('audio'));
                safeGetElement('recordVideoBtn').addEventListener('click', () => toggleRecording('video'));
                
                // SINWE Recording Mode Buttons
                document.querySelectorAll('[data-mode]').forEach(btn => {
                    btn.addEventListener('click', () => setSINWEMode(btn.dataset.mode));
                });
                
                // SINWE Sound Effect Buttons
                document.querySelectorAll('[data-effect]').forEach(btn => {
                    btn.addEventListener('click', () => triggerSINWEEffect(btn.dataset.effect));
                });
                
                // EQ Controls
                ['treble', 'mid', 'bass', 'echo'].forEach(band => {
                    const slider = safeGetElement(band);
                    slider.addEventListener('input', (e) => updateEQ(band, e.target.value));
                });
                
                // SINWE Function Buttons
                ['elimination', 'mute', 'denoise', 'voiceOver'].forEach(func => {
                    safeGetElement(func + 'Btn').addEventListener('click', () => toggleSINWEFunction(func));
                });
                
                // Connectivity Buttons
                safeGetElement('bluetoothBtn').addEventListener('click', () => {
                    KozmicStudio.sinwe.connectivity.bluetooth = !KozmicStudio.sinwe.connectivity.bluetooth;
                    const btn = safeGetElement('bluetoothBtn');
                    if (KozmicStudio.sinwe.connectivity.bluetooth) {
                        btn.classList.add('active');
                        log('Bluetooth connected', 'mixer');
                    } else {
                        btn.classList.remove('active');
                        log('Bluetooth disconnected', 'mixer');
                    }
                });
                
                safeGetElement('internalPlayBtn').addEventListener('click', () => {
                    KozmicStudio.sinwe.connectivity.internalPlay = !KozmicStudio.sinwe.connectivity.internalPlay;
                    const btn = safeGetElement('internalPlayBtn');
                    if (KozmicStudio.sinwe.connectivity.internalPlay) {
                        btn.classList.add('active');
                        log('Internal play ON', 'mixer');
                    } else {
                        btn.classList.remove('active');
                        log('Internal play OFF', 'mixer');
                    }
                });
                
                // Rhythm Controls
                safeGetElement('metronomeBtn').addEventListener('click', toggleMetronome);
                safeGetElement('tunerBtn').addEventListener('click', () => {
                    // Guitar tuner functionality would go here
                    log('Guitar tuner activated');
                });
                safeGetElement('bpmSlider').addEventListener('input', (e) => setBPM(e.target.value));
                
                // Drum Pads
                document.querySelectorAll('[data-sound]').forEach(pad => {
                    pad.addEventListener('click', () => triggerDrumSound(pad.dataset.sound));
                });
                
                // Streaming Controls
                safeGetElement('startStream').addEventListener('click', toggleStreaming);
                
                // Master Controls
                safeGetElement('saveBtn').addEventListener('click', saveSession);
                safeGetElement('loadBtn').addEventListener('click', loadSession);
                safeGetElement('exportBtn').addEventListener('click', () => {
                    log('Export functionality would export processed audio');
                    safeGetElement('masterStatus').innerHTML = 'Export feature coming soon! üéß';
                });
                safeGetElement('emergencyBtn').addEventListener('click', emergencyStop);
                safeGetElement('jamBtn').addEventListener('click', () => {
                    // Start jam session with random SINWE effects
                    const effects = ['cheer', 'awesome', 'applause'];
                    effects.forEach((effect, index) => {
                        setTimeout(() => triggerSINWEEffect(effect), index * 1000);
                    });
                    startMetronome();
                    log('Jam session started with SINWE effects!');
                });
                
                // Master Volume
                safeGetElement('masterVolume').addEventListener('input', (e) => {
                    const value = e.target.value;
                    safeGetElement('masterVolumeValue').textContent = value + '%';
                    if (KozmicStudio.effectsChain && KozmicStudio.effectsChain.outputGain) {
                        const gain = value / 100;
                        KozmicStudio.effectsChain.outputGain.gain.setValueAtTime(gain, KozmicStudio.audioContext.currentTime);
                    }
                });
                
                // Input Gain
                safeGetElement('inputGain').addEventListener('input', (e) => {
                    if (KozmicStudio.effectsChain && KozmicStudio.effectsChain.inputGain) {
                        const gain = e.target.value / 100;
                        KozmicStudio.effectsChain.inputGain.gain.setValueAtTime(gain, KozmicStudio.audioContext.currentTime);
                    }
                });
                
                // Checklist Controls
                safeGetElement('resetChecklistBtn').addEventListener('click', resetChecklist);
                safeGetElement('checkAllBtn').addEventListener('click', checkAllItems);
                
                // Cosmic Creature
                document.querySelector('.cosmic-creature').addEventListener('click', pulseCreature);
                
                // Keyboard Shortcuts
                document.addEventListener('keydown', (e) => {
                    if (e.ctrlKey && e.shiftKey) {
                        switch(e.key.toLowerCase()) {
                            case 's': saveSession(); break;
                            case 'l': loadSession(); break;
                            case 'e': emergencyStop(); break;
                        }
                    } else {
                        switch(e.key.toLowerCase()) {
                            case ' ': e.preventDefault(); toggleMetronome(); break;
                            case 'm': toggleSINWEFunction('mute'); break;
                            case 'r': toggleRecording('audio'); break;
                            case 'v': toggleRecording('video'); break;
                            case 's': toggleStreaming(); break;
                            // Drum pad shortcuts
                            case 'q': triggerDrumSound('kick'); break;
                            case 'w': triggerDrumSound('snare'); break;
                            case 'e': triggerDrumSound('hat'); break;
                            case 'r': triggerDrumSound('crash'); break;
                            case 'a': triggerDrumSound('ride'); break;
                            case 's': triggerDrumSound('tom'); break;
                            case 'd': triggerDrumSound('clap'); break;
                            case 'f': triggerDrumSound('gallop'); break;
                        }
                    }
                });
                
                log('Event listeners setup complete');
                
            } catch (e) {
                log(`Event listener setup error: ${e.message}`, 'error');
            }
        }

        // Initialization
        function initializeKozmicStudio() {
            try {
                log('üåå KOZMIC PRO STUDIO - SINWE EDITION INITIALIZING...');
                
                // Setup all event listeners
                setupEventListeners();
                
                // Initialize default SINWE state
                setSINWEMode('primal');
                
                // Update initial EQ display values
                ['treble', 'mid', 'bass', 'echo'].forEach(band => {
                    const value = KozmicStudio.sinwe.eq[band];
                    safeGetElement(band + 'Value').textContent = value + '%';
                });
                
                // Update master volume display
                safeGetElement('masterVolumeValue').textContent = '75%';
                
                // Set initial status messages
                safeGetElement('mixerStatus').innerHTML = 'SINWE Mixer Ready - 44.1kHz/16-bit';
                safeGetElement('connectionStatus').innerHTML = 'USB-C Connected<br>Ready for 3-phone streaming';
                safeGetElement('checklistStatus').innerHTML = 'Check your SINWE equipment setup!';
                
                log('üé∏ KOZMIC PRO STUDIO - SINWE EDITION READY! üé∏');
                log('Features: SINWE Mixer Integration, Multi-Platform Streaming, Professional Recording');
                
                // Initial creature pulse
                setTimeout(pulseCreature, 1000);
                
            } catch (e) {
                log(`Initialization error: ${e.message}`, 'error');
            }
        }

        // Auto-initialize when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initializeKozmicStudio);
        } else {
            initializeKozmicStudio();
        }

        // Export global functions for console debugging
        window.KozmicStudio = KozmicStudio;
        window.log = log;
        window.triggerSINWEEffect = triggerSINWEEffect;
        window.setSINWEMode = setSINWEMode;
        window.emergencyStop = emergencyStop;

        // Global error handler
        window.addEventListener('error', (e) => {
            log(`Global error: ${e.message}`, 'error');
        });

        // Cleanup on page unload
        window.addEventListener('beforeunload', () => {
            try {
                if (KozmicStudio.guitarStream) {
                    KozmicStudio.guitarStream.getTracks().forEach(track => track.stop());
                }
                if (KozmicStudio.videoStream) {
                    KozmicStudio.videoStream.getTracks().forEach(track => track.stop());
                }
                if (KozmicStudio.metronomeInterval) {
                    clearInterval(KozmicStudio.metronomeInterval);
                }
                log('Cleanup completed');
            } catch (e) {
                log(`Cleanup error: ${e.message}`, 'error');
            }
        });

    </script>
</body>
</html>
