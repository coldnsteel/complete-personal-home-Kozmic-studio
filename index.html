<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>🌌 Ultimate Cosmic Studio - COMPLETE EDITION</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: linear-gradient(45deg, #0a0a0a, #1a0033, #330066, #000066);
            color: #ffffff;
            font-family: 'Courier New', monospace;
            overflow-x: hidden;
            min-height: 100vh;
            animation: cosmicPulse 4s ease-in-out infinite;
        }
        
        @keyframes cosmicPulse {
            0%, 100% { background: linear-gradient(45deg, #0a0a0a, #1a0033, #330066, #000066); }
            25% { background: linear-gradient(45deg, #1a0033, #330066, #000066, #0a0a0a); }
            50% { background: linear-gradient(45deg, #330066, #000066, #0a0a0a, #1a0033); }
            75% { background: linear-gradient(45deg, #000066, #0a0a0a, #1a0033, #330066); }
        }
        
        .cosmic-container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
            position: relative;
        }
        
        .header {
            text-align: center;
            margin-bottom: 30px;
            animation: titleGlow 2s ease-in-out infinite alternate;
        }
        
        @keyframes titleGlow {
            from { text-shadow: 0 0 20px #00ffff, 0 0 30px #ff00ff, 0 0 40px #ffff00; }
            to { text-shadow: 0 0 30px #ff00ff, 0 0 40px #ffff00, 0 0 50px #00ffff; }
        }
        
        .module {
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #00ffff;
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
            position: relative;
        }
        
        .module.motown { border-color: #ff6b35; box-shadow: 0 0 20px rgba(255, 107, 53, 0.3); }
        .module.reggae { border-color: #00ff00; box-shadow: 0 0 20px rgba(0, 255, 0, 0.3); }
        .module.psychedelic { 
            border-color: #ff00ff; 
            box-shadow: 0 0 20px rgba(255, 0, 255, 0.3); 
            animation: psychedelicPulse 1s infinite; 
        }
        .module.wreckingCrew { border-color: #ffaa33; box-shadow: 0 0 20px rgba(255, 170, 51, 0.3); }
        .module.indian { border-color: #ff9900; box-shadow: 0 0 20px rgba(255, 153, 0, 0.3); }
        .module.african { border-color: #ffaa00; box-shadow: 0 0 20px rgba(255, 170, 0, 0.3); }
        
        @keyframes psychedelicPulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.02); }
            100% { transform: scale(1); }
        }
        
        .module-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        
        .module-title {
            font-size: 1.2em;
            font-weight: bold;
            text-transform: uppercase;
        }
        
        .module-status {
            font-size: 0.8em;
            padding: 5px 10px;
            border-radius: 10px;
            background: #00ff00;
            color: #000;
        }
        
        .control-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }
        
        .control-btn {
            background: linear-gradient(45deg, #333, #666);
            border: 2px solid #00ffff;
            color: #fff;
            padding: 15px;
            border-radius: 10px;
            cursor: pointer;
            font-family: inherit;
            font-size: 0.9em;
            transition: all 0.3s ease;
            text-transform: uppercase;
            font-weight: bold;
        }
        
        .control-btn:hover {
            background: linear-gradient(45deg, #666, #999);
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.5);
            transform: translateY(-2px);
        }
        
        .control-btn.active {
            background: linear-gradient(45deg, #00ffff, #0088ff);
            color: #000;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.7);
        }
        
        .genre-selector {
            width: 100%;
            padding: 15px;
            background: #1a1a1a;
            border: 2px solid #00ffff;
            color: #fff;
            border-radius: 10px;
            font-family: inherit;
            font-size: 1em;
            margin-bottom: 20px;
        }
        
        .instrument-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            margin: 20px 0;
        }
        
        .instrument-pad {
            background: linear-gradient(45deg, #2a2a2a, #4a4a4a);
            border: 2px solid #666;
            color: #fff;
            padding: 20px;
            border-radius: 8px;
            cursor: pointer;
            font-family: inherit;
            font-size: 0.8em;
            transition: all 0.2s ease;
            text-align: center;
        }
        
        .instrument-pad:hover {
            background: linear-gradient(45deg, #4a4a4a, #6a6a6a);
            border-color: #00ffff;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.3);
        }
        
        .instrument-pad.active {
            background: linear-gradient(45deg, #00ffaa, #0088aa);
            border-color: #00ffff;
            color: #000;
            animation: padPulse 0.3s ease;
        }
        
        @keyframes padPulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }
        
        .heuristic-panel {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #ff00ff;
            border-radius: 10px;
            padding: 15px;
            min-width: 250px;
            max-height: 400px;
            overflow-y: auto;
            z-index: 1000;
        }
        
        .heuristic-log {
            font-size: 0.7em;
            line-height: 1.2;
            margin-bottom: 5px;
            padding: 2px 5px;
            border-radius: 3px;
        }
        
        .log-pass { background: rgba(0, 255, 0, 0.2); color: #00ff00; }
        .log-fail { background: rgba(255, 0, 0, 0.2); color: #ff0000; }
        
        .error-display {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 0, 0, 0.9);
            border: 2px solid #fff;
            border-radius: 10px;
            padding: 20px;
            z-index: 2000;
            display: none;
            text-align: center;
            box-shadow: 0 0 20px rgba(255, 0, 0, 0.7);
        }
        
        .waveform-timeline {
            width: 100%;
            max-width: 1000px;
            height: 200px;
            background: #1a1a1a;
            border: 2px solid #00ffff;
            border-radius: 10px;
            margin: 20px 0;
        }
        
        .mixer-track {
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 8px;
            text-align: center;
            border: 1px solid #333;
            margin: 5px;
        }
        
        .fader {
            width: 20px;
            height: 100px;
            -webkit-appearance: slider-vertical;
            writing-mode: bt-lr;
            background: #333;
            margin: 10px auto;
        }
        
        .pan-knob {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(45deg, #333, #666);
            border: 2px solid #00ffff;
            cursor: pointer;
            margin: 10px auto;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #fff;
            font-size: 0.8em;
        }
        
        .chat-panel {
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 8px;
            margin: 20px 0;
            height: 200px;
            overflow-y: auto;
            border: 1px solid #333;
        }
        
        .volume-meter {
            width: 100%;
            height: 20px;
            background: #333;
            border-radius: 10px;
            overflow: hidden;
            margin: 10px 0;
        }
        
        .volume-bar {
            height: 100%;
            background: linear-gradient(90deg, #00ff00, #ffff00, #ff0000);
            width: 0%;
            transition: width 0.1s ease;
        }
        
        .emergency-stop {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background: #ff0000;
            border: 4px solid #fff;
            color: #fff;
            font-size: 1.2em;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            animation: emergencyPulse 2s infinite;
            z-index: 1000;
        }
        
        @keyframes emergencyPulse {
            0%, 100% { box-shadow: 0 0 0 0 rgba(255, 0, 0, 0.7); }
            50% { box-shadow: 0 0 0 20px rgba(255, 0, 0, 0); }
        }
        
        .spectrum-analyzer {
            width: 100%;
            height: 100px;
            background: #000;
            border: 2px solid #00ffff;
            border-radius: 8px;
            margin: 10px 0;
        }
        
        .ai-assistant {
            background: rgba(0, 255, 255, 0.1);
            border: 2px solid #00ffff;
            border-radius: 10px;
            padding: 15px;
            margin: 20px 0;
        }
        
        .session-manager {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin: 20px 0;
        }
    </style>
</head>
<body>
    <script>
        console.log("🌌 Starting Ultimate Cosmic Studio - COMPLETE EDITION 🌌");
        
        // Enhanced Global Variables
        let audioContext = null;
        let masterGain = null;
        let currentGenre = 'standard';
        let isTesting = false;
        let recordedTracks = [];
        let mediaRecorders = [];
        let tracks = [];
        let currentSession = null;
        let collaborationActive = false;
        let aiAssistantActive = false;
        let analyserNode = null;
        let volumeMeterActive = false;
        
        // Enhanced Data Objects
        const genres = {
            standard: {
                name: 'Standard',
                instruments: ['Kick', 'Snare', 'Hi-Hat', 'Crash', 'Bass', 'Guitar', 'Keys', 'Vocals'],
                style: 'standard',
                bpm: 120,
                key: 'C',
                scale: 'major'
            },
            motown: {
                name: 'Motown (Funk Brothers)', 
                instruments: ['Jamerson Bass', 'Benny Drums', 'Messina Guitar', 'Van Dyke Keys', 'Horns', 'Strings', 'Tamb', 'Vocals'],
                style: 'motown',
                bpm: 110,
                key: 'F',
                scale: 'major',
                samples: {
                    'Jamerson Bass': { url: 'data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+DyvmMbBDWL0fPNeSsFJG/E8OGSQwoUXLLn7K1aFglAl93yukBiNTjD7t+8FJcWeH+L3+9z6dU6+VZ3G1XgceTf7tCxXTj8VIkAnhKNIGhEqAD20AxTD6gQUxDwAI4Q8ADwAI4AjgCOAI4AjgCOAI4A' },
                    'Benny Drums': { url: 'data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+DyvmMbBDWL0fPNeSsFJG/E8OGSQwoUXLLn7K1aFglAl93yukBiNTjD7t+8FJcWeH+L3+9z6dU6+VZ3G1XgceTf7tCxXTj8VIkAnhKNIGhEqAD20AxTD6gQUxDwAI4Q8ADwAI4AjgCOAI4AjgCOAI4A' }
                }
            },
            wreckingCrew: {
                name: 'Wrecking Crew',
                instruments: ['Kaye Bass', 'Blaine Drums', 'Tedesco Guitar', 'Knechtel Keys', 'Horns', 'Percussion', 'Piano', 'Vibes'], 
                style: 'wreckingCrew',
                bpm: 130,
                key: 'G',
                scale: 'major'
            },
            reggae: {
                name: 'Reggae',
                instruments: ['Bass Drop', 'Skank Guitar', 'One Drop', 'Rim Shot', 'Organ', 'Melodica', 'Horns', 'Dub Delay'],
                style: 'reggae',
                bpm: 80,
                key: 'A',
                scale: 'minor'
            },
            psychedelic: {
                name: 'Psychedelic',
                instruments: ['Fuzz Bass', 'Wah Guitar', 'Reverse Cymbal', 'Phaser Drums', 'Mellotron', 'Sitar', 'Theremin', 'Cosmic Pad'],
                style: 'psychedelic',
                bpm: 140,
                key: 'E',
                scale: 'mixolydian'
            },
            indian: {
                name: 'Indian Classical',
                instruments: ['Sitar', 'Tabla', 'Tanpura', 'Bansuri', 'Harmonium', 'Veena', 'Mridangam', 'Drone'],
                style: 'indian',
                bpm: 90,
                key: 'D',
                scale: 'raga_yaman',
                microtonal: true,
                tuning: [261.63, 275.22, 294.33, 311.13, 329.63, 348.45, 370.99, 392.00] // Simplified raga
            },
            african: {
                name: 'African Polyrhythms',
                instruments: ['Djembe', 'Kora', 'Balafon', 'Shekere', 'Dundun', 'Talking Drum', 'Kalimba', 'Ngoni'],
                style: 'african',
                bpm: 100,
                key: 'Bb',
                scale: 'pentatonic'
            }
        };
        
        const appleLoops = {
            motown: ['Jamerson Groove', 'Benny Beat', 'Van Dyke Chords', 'Horn Stabs', 'Tamla Strings', 'Soul Claps', 'Detroit Bass', 'Motown Organ'],
            wreckingCrew: ['Blaine Beat', 'Kaye Groove', 'Tedesco Riff', 'Knechtel Chords', 'Wall of Sound', 'Studio Perc', 'Spector Hall', 'LA Session'],
            reggae: ['One Drop Beat', 'Skank Guitar', 'Bass Drop', 'Organ Bubble', 'Dub Effects', 'Rastafari', 'Steppers', 'Rockers'],
            psychedelic: ['Cosmic Drums', 'Fuzz Bass', 'Wah Guitar', 'Mellotron', 'Reverse FX', 'Space Echo', 'Phaser Sweep', 'Acid Rock'],
            indian: ['Sitar Raga', 'Tabla Bols', 'Tanpura Drone', 'Bansuri Melody', 'Shruti Scale', 'Classical Taal', 'Hindustani', 'Carnatic'],
            african: ['Djembe Polyrhythm', 'Kora Cascades', 'Balafon Melody', 'Talking Drum', 'Call Response', 'Tribal Chant', 'Afrobeat', 'Highlife'],
            standard: ['Basic Beat', 'Simple Bass', 'Clean Guitar', 'Piano', 'Strings', 'Percussion', 'Pop Beat', 'Rock Guitar']
        };
        
        const uadPlugins = {
            'LA-610': { type: 'preamp', name: 'Tube Preamp', value: 0, node: null, bypass: false },
            'Ruby 63': { type: 'amp', name: 'Top Boost Amp', value: 0, node: null, bypass: false },
            'LA-2A': { type: 'compressor', name: 'Leveler', value: 0, node: null, bypass: false },
            'LA-3A': { type: 'compressor', name: 'Compressor', value: 0, node: null, bypass: false },
            '1176': { type: 'compressor', name: 'FET Compressor', value: 0, node: null, bypass: false },
            'Lexicon 224': { type: 'reverb', name: 'Digital Reverb', value: 0, node: null, bypass: false },
            'Galaxy': { type: 'delay', name: 'Tape Echo', value: 0, node: null, bypass: false },
            'Hitsville': { type: 'reverb', name: 'Reverb Chambers', value: 0, node: null, bypass: false },
            'Pultec': { type: 'eq', name: 'EQ Collection', value: 0, node: null, bypass: false },
            'Verve': { type: 'tape', name: 'Analog Machines', value: 0, node: null, bypass: false },
            'Opal': { type: 'synth', name: 'Morphing Synth', value: 0, node: null, bypass: false },
            'Brigade': { type: 'chorus', name: 'Chorus', value: 0, node: null, bypass: false }
        };
        
        // Enhanced Error Handling
        window.onerror = function(message, source, lineno, colno, error) {
            showError(`JavaScript Error: ${message} at line ${lineno}`);
            addLog('error', 'JAVASCRIPT_ERROR', false, `${message} at line ${lineno}`);
            return false;
        };

        window.addEventListener('unhandledrejection', function(event) {
            showError(`Promise Error: ${event.reason}`);
            addLog('error', 'PROMISE_REJECTION', false, event.reason);
        });

        function showError(message) {
            try {
                const errorDisplay = document.getElementById('errorDisplay');
                const errorMessage = document.getElementById('errorMessage');
                errorMessage.textContent = message;
                errorDisplay.style.display = 'block';
                addLog('system', 'ERROR_DISPLAY', true, message);
            } catch (error) {
                console.error('Error in showError:', error);
            }
        }

        function closeErrorDisplay() {
            try {
                document.getElementById('errorDisplay').style.display = 'none';
                addLog('system', 'ERROR_CLEARED', true, 'Error display closed');
            } catch (error) {
                console.error('Error in closeErrorDisplay:', error);
            }
        }
        
        // Enhanced Logging Function
        function addLog(module, test, result, details) {
            const timestamp = new Date().toLocaleTimeString();
            const logMessage = `[${module}] ${test}: ${result ? 'PASS' : 'FAIL'} ${details || ''}`;
            console.log(`${timestamp} ${logMessage}`);
            
            try {
                const logElement = document.getElementById('heuristicLog');
                if (logElement) {
                    const logDiv = document.createElement('div');
                    logDiv.className = `heuristic-log ${result ? 'log-pass' : 'log-fail'}`;
                    logDiv.innerHTML = `${timestamp} ${logMessage}`;
                    
                    logElement.appendChild(logDiv);
                    logElement.scrollTop = logElement.scrollHeight;
                    
                    if (logElement.children.length > 100) {
                        logElement.removeChild(logElement.firstChild);
                    }
                }
            } catch (error) {
                console.error('Logging error:', error);
            }
        }
        
        // Enhanced Audio System
        function connectAudio() {
            console.log("connectAudio called");
            addLog('audio', 'CONNECT_START', true, 'Attempting audio connection');
            
            try {
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                if (!AudioContext) {
                    addLog('audio', 'CONNECT', false, 'Web Audio API not supported');
                    showError('Web Audio API not supported');
                    return;
                }
                
                audioContext = new AudioContext();
                masterGain = audioContext.createGain();
                masterGain.connect(audioContext.destination);
                masterGain.gain.value = 0.7;
                
                // Initialize spectrum analyzer
                analyserNode = audioContext.createAnalyser();
                analyserNode.fftSize = 256;
                masterGain.connect(analyserNode);
                
                initUADNodes();
                initMixer();
                startVolumeMonitoring();
                updateStatus('connection', 'ONLINE');
                addLog('audio', 'CONNECT', true, 'Audio context created successfully');
                
                event.target.classList.add('active');
            } catch (error) {
                addLog('audio', 'CONNECT', false, error.message);
                updateStatus('connection', 'ERROR');
                showError(`Audio connection failed: ${error.message}`);
            }
        }
        
        function initUADNodes() {
            try {
                if (!audioContext) return;
                
                Object.entries(uadPlugins).forEach(([id, config]) => {
                    if (config.type === 'compressor') {
                        config.node = audioContext.createDynamicsCompressor();
                        config.node.threshold.setValueAtTime(-50, audioContext.currentTime);
                        config.node.ratio.setValueAtTime(4, audioContext.currentTime);
                        config.node.attack.setValueAtTime(0.003, audioContext.currentTime);
                        config.node.release.setValueAtTime(0.25, audioContext.currentTime);
                    } else if (config.type === 'reverb') {
                        config.node = audioContext.createConvolver();
                        // Create impulse response for reverb
                        const impulseLength = audioContext.sampleRate * 2;
                        const impulse = audioContext.createBuffer(2, impulseLength, audioContext.sampleRate);
                        for (let channel = 0; channel < 2; channel++) {
                            const channelData = impulse.getChannelData(channel);
                            for (let i = 0; i < impulseLength; i++) {
                                channelData[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / impulseLength, 2);
                            }
                        }
                        config.node.buffer = impulse;
                    } else if (config.type === 'preamp') {
                        config.node = audioContext.createWaveShaper();
                        config.node.curve = makeDistortionCurve(100);
                        config.node.oversample = '4x';
                    } else if (config.type === 'delay') {
                        config.node = audioContext.createDelay(1);
                        config.node.delayTime.setValueAtTime(0.3, audioContext.currentTime);
                    } else if (config.type === 'eq') {
                        config.node = audioContext.createBiquadFilter();
                        config.node.type = 'peaking';
                        config.node.frequency.setValueAtTime(1000, audioContext.currentTime);
                        config.node.Q.setValueAtTime(1, audioContext.currentTime);
                    } else {
                        config.node = audioContext.createGain();
                        config.node.gain.setValueAtTime(1, audioContext.currentTime);
                    }
                });
                
                addLog('uad', 'INIT_NODES', true, 'UAD audio nodes initialized');
            } catch (error) {
                addLog('uad', 'INIT_NODES', false, error.message);
                showError(`UAD nodes initialization failed: ${error.message}`);
            }
        }
        
        function makeDistortionCurve(amount) {
            try {
                const samples = 44100;
                const curve = new Float32Array(samples);
                const deg = Math.PI / 180;
                
                for (let i = 0; i < samples; ++i) {
                    const x = (i * 2) / samples - 1;
                    curve[i] = ((3 + amount) * x * 20 * deg) / (Math.PI + amount * Math.abs(x));
                }
                return curve;
            } catch (error) {
                addLog('uad', 'DISTORTION_CURVE', false, error.message);
                return null;
            }
        }
        
        function startVolumeMonitoring() {
            if (!analyserNode) return;
            
            volumeMeterActive = true;
            const bufferLength = analyserNode.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);
            
            function updateVolumeMeter() {
                if (!volumeMeterActive) return;
                
                analyserNode.getByteFrequencyData(dataArray);
                const average = dataArray.reduce((a, b) => a + b) / bufferLength;
                const volumePercent = (average / 255) * 100;
                
                const volumeBar = document.getElementById('volumeBar');
                if (volumeBar) {
                    volumeBar.style.width = `${volumePercent}%`;
                }
                
                requestAnimationFrame(updateVolumeMeter);
            }
            
            updateVolumeMeter();
            addLog('audio', 'VOLUME_MONITORING', true, 'Real-time volume monitoring started');
        }
        
        // Enhanced Sample Loading
        async function loadSample(url) {
            try {
                if (url.startsWith('data:')) {
                    // Handle base64 encoded samples
                    const response = await fetch(url);
                    const arrayBuffer = await response.arrayBuffer();
                    return await audioContext.decodeAudioData(arrayBuffer);
                } else {
                    // Handle external URLs
                    const response = await fetch(url);
                    const arrayBuffer = await response.arrayBuffer();
                    return await audioContext.decodeAudioData(arrayBuffer);
                }
            } catch (error) {
                addLog('instrument', 'LOAD_SAMPLE', false, error.message);
                throw error;
            }
        }
        
        // Enhanced Instrument Playback
        function playInstrument(index, instrument) {
            console.log("playInstrument called:", index, instrument);
            
            if (!audioContext) {
                addLog('instrument', 'PLAY', false, 'Audio not connected');
                showError('Audio not connected');
                return;
            }
            
            try {
                const genreData = genres[currentGenre];
                
                // Check for samples first
                if (genreData.samples && genreData.samples[instrument]) {
                    loadSample(genreData.samples[instrument].url).then(buffer => {
                        const source = audioContext.createBufferSource();
                        source.buffer = buffer;
                        
                        // Route through UAD plugins
                        let currentNode = source;
                        Object.values(uadPlugins).forEach(plugin => {
                            if (plugin.node && !plugin.bypass) {
                                currentNode.connect(plugin.node);
                                currentNode = plugin.node;
                            }
                        });
                        
                        currentNode.connect(masterGain);
                        source.start();
                        addLog('instrument', 'PLAY_SAMPLE', true, `${instrument} sample`);
                        
                        event.target.classList.add('active');
                        setTimeout(() => event.target.classList.remove('active'), 300);
                    }).catch(err => {
                        addLog('instrument', 'PLAY_SAMPLE', false, err.message);
                        playOscillatorInstrument(index, instrument, genreData);
                    });
                    return;
                }
                
                playOscillatorInstrument(index, instrument, genreData);
            } catch (error) {
                addLog('instrument', 'PLAY', false, error.message);
                showError(`Instrument playback failed: ${error.message}`);
            }
        }
        
        function playOscillatorInstrument(index, instrument, genreData) {
            try {
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                let frequencies;
                if (genreData.microtonal && genreData.tuning) {
                    frequencies = genreData.tuning;
                } else {
                    frequencies = [130, 146, 164, 174, 196, 220, 246, 261];
                }
                
                oscillator.frequency.setValueAtTime(frequencies[index % frequencies.length], audioContext.currentTime);
                
                // Genre-specific waveforms and effects
                switch (currentGenre) {
                    case 'african':
                        oscillator.type = 'triangle';
                        break;
                    case 'psychedelic':
                        oscillator.type = 'sawtooth';
                        // Add subtle frequency modulation
                        const lfo = audioContext.createOscillator();
                        const lfoGain = audioContext.createGain();
                        lfo.frequency.setValueAtTime(0.5, audioContext.currentTime);
                        lfoGain.gain.setValueAtTime(10, audioContext.currentTime);
                        lfo.connect(lfoGain);
                        lfoGain.connect(oscillator.frequency);
                        lfo.start();
                        lfo.stop(audioContext.currentTime + 0.5);
                        break;
                    case 'reggae':
                        oscillator.type = 'square';
                        break;
                    default:
                        oscillator.type = 'sine';
                }
                
                gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
                
                // Route through UAD plugins
                let currentNode = oscillator;
                Object.values(uadPlugins).forEach(plugin => {
                    if (plugin.node && !plugin.bypass) {
                        currentNode.connect(plugin.node);
                        currentNode = plugin.node;
                    }
                });
                
                currentNode.connect(gainNode);
                gainNode.connect(masterGain);
                
                oscillator.start();
                oscillator.stop(audioContext.currentTime + 0.5);
                
                event.target.classList.add('active');
                setTimeout(() => event.target.classList.remove('active'), 300);
                
                addLog('instrument', 'PLAY', true, instrument);
            } catch (error) {
                addLog('instrument', 'PLAY', false, error.message);
                showError(`Oscillator playback failed: ${error.message}`);
            }
        }
        
        // Enhanced Genre System
        function changeGenre(genre) {
            console.log("changeGenre called with:", genre);
            addLog('genre', 'CHANGE_START', true, `Switching to ${genre}`);
            
            try {
                const genreData = genres[genre];
                if (!genreData) {
                    addLog('genre', 'CHANGE', false, `Genre ${genre} not found`);
                    showError(`Genre ${genre} not found`);
                    return;
                }
                
                currentGenre = genre;
                
                const genreModule = document.getElementById('genreModule');
                if (genreModule) {
                    genreModule.className = `module ${genreData.style}`;
                }
                
                populateInstruments(genreData.instruments);
                populateLoops();
                updateGenreInfo(genreData);
                
                addLog('genre', 'CHANGE', true, `Successfully switched to ${genre}`);
                updateStatus('genre', 'ACTIVE');
            } catch (error) {
                addLog('genre', 'CHANGE', false, error.message);
                showError(`Genre change failed: ${error.message}`);
            }
        }
        
        function updateGenreInfo(genreData) {
            try {
                const infoDiv = document.getElementById('genreInfo');
                if (infoDiv) {
                    infoDiv.innerHTML = `
                        <strong>${genreData.name}</strong><br>
                        BPM: ${genreData.bpm} | Key: ${genreData.key} | Scale: ${genreData.scale}
                        ${genreData.microtonal ? ' | Microtonal Tuning' : ''}
                    `;
                }
            } catch (error) {
                addLog('genre', 'UPDATE_INFO', false, error.message);
            }
        }
        
        // Enhanced Recording System
        function startRecording() {
            try {
                if (!audioContext) {
                    addLog('recording', 'START', false, 'Audio not connected');
                    showError('Audio not connected');
                    return;
                }
                
                navigator.mediaDevices.getUserMedia({ audio: true }).then(stream => {
                    const source = audioContext.createMediaStreamSource(stream);
                    const recorder = new MediaRecorder(stream, {
                        mimeType: 'audio/webm;codecs=opus',
                        audioBitsPerSecond: 128000
                    });
                    let chunks = [];
                    
                    recorder.ondataavailable = e => chunks.push(e.data);
                    recorder.onstop = () => {
                        const blob = new Blob(chunks, { type: 'audio/webm' });
                        const trackData = {
                            blob,
                            timestamp: Date.now(),
                            name: `Track ${recordedTracks.length + 1}`,
                            genre: currentGenre,
                            duration: Date.now() - startTime
                        };
                        recordedTracks.push(trackData);
                        drawWaveform();
                        updateTrackList();
                        addLog('recording', 'TRACK_RECORDED', true, `Track ${recordedTracks.length} recorded`);
                    };
                    
                    const startTime = Date.now();
                    recorder.start();
                    mediaRecorders.push(recorder);
                    updateStatus('recording', 'RECORDING');
                    addLog('recording', 'START', true, 'Recording started');
                }).catch(error => {
                    addLog('recording', 'START', false, error.message);
                    showError(`Recording failed: ${error.message}`);
                });
            } catch (error) {
                addLog('recording', 'START', false, error.message);
                showError(`Recording setup failed: ${error.message}`);
            }
        }
        
        function stopRecording() {
            try {
                mediaRecorders.forEach(recorder => recorder.stop());
                mediaRecorders = [];
                updateStatus('recording', 'READY');
                addLog('recording', 'STOP', true, 'Recording stopped');
            } catch (error) {
                addLog('recording', 'STOP', false, error.message);
                showError(`Stop recording failed: ${error.message}`);
            }
        }
        
        function drawWaveform() {
            try {
                const canvas = document.getElementById('waveformTimeline');
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = '#1a1a1a';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                recordedTracks.forEach((track, index) => {
                    const x = 50 * index;
                    const width = Math.min(40, (track.duration / 1000) * 10);
                    const height = 80 + Math.random() * 40;
                    
                    ctx.fillStyle = `hsl(${180 + index * 30}, 70%, 50%)`;
                    ctx.fillRect(x, 50, width, height);
                    
                    ctx.fillStyle = '#fff';
                    ctx.font = '10px monospace';
                    ctx.fillText(track.name, x, 45);
                });
                
                addLog('recording', 'DRAW_WAVEFORM', true, 'Waveform drawn');
            } catch (error) {
                addLog('recording', 'DRAW_WAVEFORM', false, error.message);
            }
        }
        
        function updateTrackList() {
            try {
                const trackList = document.getElementById('trackList');
                if (trackList) {
                    trackList.innerHTML = '';
                    recordedTracks.forEach((track, index) => {
                        const trackDiv = document.createElement('div');
                        trackDiv.className = 'track-item';
                        trackDiv.innerHTML = `
                            <span>${track.name}</span>
                            <span>${track.genre}</span>
                            <button onclick="playTrack(${index})">Play</button>
                            <button onclick="deleteTrack(${index})">Delete</button>
                        `;
                        trackList.appendChild(trackDiv);
                    });
                }
            } catch (error) {
                addLog('recording', 'UPDATE_TRACK_LIST', false, error.message);
            }
        }
        
        function playTrack(index) {
            try {
                const track = recordedTracks[index];
                const audio = new Audio(URL.createObjectURL(track.blob));
                audio.play();
                addLog('recording', 'PLAY_TRACK', true, `Playing ${track.name}`);
            } catch (error) {
                addLog('recording', 'PLAY_TRACK', false, error.message);
            }
        }
        
        function deleteTrack(index) {
            try {
                const track = recordedTracks[index];
                recordedTracks.splice(index, 1);
                drawWaveform();
                updateTrackList();
                addLog('recording', 'DELETE_TRACK', true, `Deleted ${track.name}`);
            } catch (error) {
                addLog('recording', 'DELETE_TRACK', false, error.message);
            }
        }
        
        function exportSession() {
            try {
                if (recordedTracks.length === 0) {
                    addLog('recording', 'EXPORT', false, 'No tracks to export');
                    showError('No tracks to export');
                    return;
                }
                
                const sessionData = {
                    tracks: recordedTracks.map(track => ({
                        name: track.name,
                        genre: track.genre,
                        timestamp: track.timestamp,
                        duration: track.duration
                    })),
                    genre: currentGenre,
                    timestamp: Date.now(),
                    version: '1.0'
                };
                
                const blob = new Blob([JSON.stringify(sessionData, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `cosmic-session-${Date.now()}.json`;
                a.click();
                URL.revokeObjectURL(url);
                
                addLog('recording', 'EXPORT', true, 'Session exported');
            } catch (error) {
                addLog('recording', 'EXPORT', false, error.message);
                showError(`Session export failed: ${error.message}`);
            }
        }
        
        // Enhanced Mixer System
        function initMixer() {
            try {
                addTrack();
                addTrack();
                addTrack();
                addTrack();
                addLog('mixer', 'INIT', true, 'Mixer initialized with 4 tracks');
            } catch (error) {
                addLog('mixer', 'INIT', false, error.message);
                showError(`Mixer initialization failed: ${error.message}`);
            }
        }
        
        function addTrack() {
            try {
                if (!audioContext) {
                    addLog('mixer', 'ADD_TRACK', false, 'Audio not connected');
                    showError('Audio not connected');
                    return;
                }
                
                const gainNode = audioContext.createGain();
                const panNode = audioContext.createStereoPanner();
                const eqNode = audioContext.createBiquadFilter();
                
                eqNode.type = 'peaking';
                eqNode.frequency.setValueAtTime(1000, audioContext.currentTime);
                eqNode.Q.setValueAtTime(1, audioContext.currentTime);
                
                gainNode.connect(eqNode);
                eqNode.connect(panNode);
                panNode.connect(masterGain);
                
                const trackId = tracks.length;
                tracks.push({ 
                    gainNode, 
                    panNode, 
                    eqNode,
                    volume: 1, 
                    pan: 0,
                    eq: 0,
                    muted: false,
                    soloed: false,
                    name: `Track ${trackId + 1}`
                });
                
                const tracksContainer = document.getElementById('mixerTracks');
                const trackDiv = document.createElement('div');
                trackDiv.className = 'mixer-track';
                trackDiv.innerHTML = `
                    <div><strong>${tracks[trackId].name}</strong></div>
                    <div>Vol</div>
                    <input type="range" class="fader" min="0" max="1" step="0.01" value="1" 
                           oninput="adjustVolume(${trackId}, this.value)" orient="vertical">
                    <div>Pan</div>
                    <div class="pan-knob" onclick="cyclePan(${trackId})">${Math.round(tracks[trackId].pan * 100)}</div>
                    <div>EQ</div>
                    <input type="range" min="-20" max="20" step="0.1" value="0" 
                           oninput="adjustEQ(${trackId}, this.value)">
                    <button class="control-btn" onclick="soloTrack(${trackId})" 
                            style="font-size: 0.7em; padding: 5px;">Solo</button>
                    <button class="control-btn" onclick="muteTrack(${trackId})" 
                            style="font-size: 0.7em; padding: 5px;">Mute</button>
                `;
                tracksContainer.appendChild(trackDiv);
                
                addLog('mixer', 'ADD_TRACK', true, `Track ${trackId + 1} added`);
            } catch (error) {
                addLog('mixer', 'ADD_TRACK', false, error.message);
                showError(`Add track failed: ${error.message}`);
            }
        }
        
        function adjustVolume(trackId, value) {
            try {
                tracks[trackId].volume = value;
                tracks[trackId].gainNode.gain.setValueAtTime(value, audioContext.currentTime);
                addLog('mixer', 'ADJUST_VOLUME', true, `Track ${trackId + 1} volume: ${value}`);
            } catch (error) {
                addLog('mixer', 'ADJUST_VOLUME', false, error.message);
            }
        }
        
        function cyclePan(trackId) {
            try {
                const currentPan = tracks[trackId].pan;
                const newPan = currentPan >= 0.5 ? -1 : currentPan + 0.5;
                tracks[trackId].pan = newPan;
                tracks[trackId].panNode.pan.setValueAtTime(newPan, audioContext.currentTime);
                
                // Update display
                const panKnob = event.target;
                panKnob.textContent = Math.round(newPan * 100);
                
                addLog('mixer', 'ADJUST_PAN', true, `Track ${trackId + 1} pan: ${newPan}`);
            } catch (error) {
                addLog('mixer', 'ADJUST_PAN', false, error.message);
            }
        }
        
        function adjustEQ(trackId, value) {
            try {
                tracks[trackId].eq = value;
                tracks[trackId].eqNode.gain.setValueAtTime(value, audioContext.currentTime);
                addLog('mixer', 'ADJUST_EQ', true, `Track ${trackId + 1} EQ: ${value}dB`);
            } catch (error) {
                addLog('mixer', 'ADJUST_EQ', false, error.message);
            }
        }
        
        function soloTrack(trackId) {
            try {
                const track = tracks[trackId];
                track.soloed = !track.soloed;
                
                tracks.forEach((t, index) => {
                    if (track.soloed) {
                        t.gainNode.gain.setValueAtTime(index === trackId ? t.volume : 0, audioContext.currentTime);
                    } else {
                        t.gainNode.gain.setValueAtTime(t.muted ? 0 : t.volume, audioContext.currentTime);
                    }
                });
                
                addLog('mixer', 'SOLO', true, `Track ${trackId + 1} ${track.soloed ? 'soloed' : 'unsoloed'}`);
            } catch (error) {
                addLog('mixer', 'SOLO', false, error.message);
            }
        }
        
        function muteTrack(trackId) {
            try {
                const track = tracks[trackId];
                track.muted = !track.muted;
                tracks[trackId].gainNode.gain.setValueAtTime(track.muted ? 0 : track.volume, audioContext.currentTime);
                addLog('mixer', 'MUTE', true, `Track ${trackId + 1} ${track.muted ? 'muted' : 'unmuted'}`);
            } catch (error) {
                addLog('mixer', 'MUTE', false, error.message);
            }
        }
        
        function applyMasterProcessing() {
            try {
                const masterCompressor = audioContext.createDynamicsCompressor();
                const masterLimiter = audioContext.createDynamicsCompressor();
                
                masterCompressor.threshold.setValueAtTime(-24, audioContext.currentTime);
                masterCompressor.ratio.setValueAtTime(3, audioContext.currentTime);
                masterCompressor.attack.setValueAtTime(0.003, audioContext.currentTime);
                masterCompressor.release.setValueAtTime(0.25, audioContext.currentTime);
                
                masterLimiter.threshold.setValueAtTime(-0.1, audioContext.currentTime);
                masterLimiter.ratio.setValueAtTime(20, audioContext.currentTime);
                
                masterGain.disconnect();
                masterGain.connect(masterCompressor);
                masterCompressor.connect(masterLimiter);
                masterLimiter.connect(audioContext.destination);
                
                addLog('mixer', 'MASTER_PROCESSING', true, 'Master bus processing applied');
            } catch (error) {
                addLog('mixer', 'MASTER_PROCESSING', false, error.message);
            }
        }
        
        // Enhanced UAD System
        function toggleUAD(plugin) {
            console.log("toggleUAD called:", plugin);
            try {
                const config = uadPlugins[plugin];
                config.value = (config.value + 25) % 101;
                
                if (config.node) {
                    switch (config.type) {
                        case 'compressor':
                            const threshold = -50 + (config.value / 100) * 40;
                            config.node.threshold.setValueAtTime(threshold, audioContext.currentTime);
                            break;
                        case 'reverb':
                            const wetness = config.value / 100;
                            if (config.node.gain) {
                                config.node.gain.setValueAtTime(wetness, audioContext.currentTime);
                            }
                            break;
                        case 'delay':
                            const delayTime = 0.1 + (config.value / 100) * 0.4;
                            config.node.delayTime.setValueAtTime(delayTime, audioContext.currentTime);
                            break;
                        case 'eq':
                            const gain = -20 + (config.value / 100) * 40;
                            config.node.gain.setValueAtTime(gain, audioContext.currentTime);
                            break;
                    }
                }
                
                populateUAD();
                addLog('uad', 'TOGGLE_PLUGIN', true, `${plugin} set to ${config.value}%`);
            } catch (error) {
                addLog('uad', 'TOGGLE_PLUGIN', false, error.message);
            }
        }
        
        function bypassUAD(plugin) {
            try {
                if (plugin) {
                    uadPlugins[plugin].bypass = !uadPlugins[plugin].bypass;
                    addLog('uad', 'BYPASS', true, `${plugin} ${uadPlugins[plugin].bypass ? 'bypassed' : 'enabled'}`);
                } else {
                    Object.values(uadPlugins).forEach(p => p.bypass = true);
                    addLog('uad', 'BYPASS_ALL', true, 'All UAD plugins bypassed');
                }
                populateUAD();
            } catch (error) {
                addLog('uad', 'BYPASS', false, error.message);
            }
        }
        
        // Enhanced Collaboration System
        function startCollaboration() {
            try {
                collaborationActive = true;
                const chatPanel = document.getElementById('chatPanel');
                chatPanel.innerHTML = `
                    <div style="color: #00ff00; font-weight: bold;">🌐 Collaboration Session Started</div>
                    <div style="color: #ccc; font-size: 0.8em;">Session ID: ${Date.now().toString(36)}</div>
                    <div style="color: #ccc; font-size: 0.8em;">Share this session with other musicians</div>
                `;
                
                // Simulate real-time updates
                setInterval(() => {
                    if (collaborationActive && Math.random() > 0.9) {
                        addCollaborationMessage('AI Assistant', 'Suggested chord progression: Cmaj7 - Am7 - Fmaj7 - G7');
                    }
                }, 5000);
                
                addLog('collaboration', 'START', true, 'Collaboration session started');
            } catch (error) {
                addLog('collaboration', 'START', false, error.message);
            }
        }
        
        function sendChatMessage() {
            try {
                const message = prompt('Enter chat message:');
                if (message) {
                    addCollaborationMessage('You', message);
                    addLog('collaboration', 'CHAT', true, `Sent: ${message}`);
                    
                    // Simulate responses
                    setTimeout(() => {
                        const responses = [
                            'Great idea!',
                            'Let me try that chord',
                            'How about we add some reverb?',
                            'That rhythm sounds amazing',
                            'Can you play that again?'
                        ];
                        const response = responses[Math.floor(Math.random() * responses.length)];
                        addCollaborationMessage('Collaborator', response);
                    }, 1000 + Math.random() * 3000);
                }
            } catch (error) {
                addLog('collaboration', 'CHAT', false, error.message);
            }
        }
        
        function addCollaborationMessage(user, message) {
            try {
                const chatPanel = document.getElementById('chatPanel');
                const msgDiv = document.createElement('div');
                msgDiv.innerHTML = `
                    <span style="color: #00ffff; font-weight: bold;">${user}:</span>
                    <span style="color: #fff;">${message}</span>
                `;
                msgDiv.style.margin = '5px 0';
                msgDiv.style.fontSize = '0.8em';
                chatPanel.appendChild(msgDiv);
                chatPanel.scrollTop = chatPanel.scrollHeight;
            } catch (error) {
                addLog('collaboration', 'ADD_MESSAGE', false, error.message);
            }
        }
        
        // AI Assistant System
        function initAIAssistant() {
            try {
                aiAssistantActive = true;
                const assistantPanel = document.getElementById('aiAssistant');
                if (assistantPanel) {
                    assistantPanel.innerHTML = `
                        <h3>🤖 AI Music Assistant</h3>
                        <div id="aiSuggestions"></div>
                        <button class="control-btn" onclick="getAISuggestion()">Get Suggestion</button>
                        <button class="control-btn" onclick="analyzeCurrentJam()">Analyze Jam</button>
                    `;
                }
                addLog('ai', 'INIT', true, 'AI Assistant initialized');
            } catch (error) {
                addLog('ai', 'INIT', false, error.message);
            }
        }
        
        function getAISuggestion() {
            try {
                const suggestions = [
                    `For ${currentGenre} music, try using the ${Math.floor(Math.random() * 8) + 1} instrument with a syncopated rhythm`,
                    `Consider adding some reverb with the Lexicon 224 plugin at 75%`,
                    `The current key of ${genres[currentGenre].key} works well with a minor seventh chord`,
                    `Try recording a bass line first, then layer drums on top`,
                    `Add some stereo width by panning instruments left and right`,
                    `Use the 1176 compressor on your drums for more punch`,
                    `Experiment with the delay plugin for ambient textures`
                ];
                
                const suggestion = suggestions[Math.floor(Math.random() * suggestions.length)];
                const suggestionsDiv = document.getElementById('aiSuggestions');
                if (suggestionsDiv) {
                    suggestionsDiv.innerHTML = `
                        <div style="background: rgba(0,255,255,0.1); padding: 10px; border-radius: 5px; margin: 10px 0;">
                            💡 ${suggestion}
                        </div>
                    `;
                }
                addLog('ai', 'SUGGESTION', true, suggestion);
            } catch (error) {
                addLog('ai', 'SUGGESTION', false, error.message);
            }
        }
        
        function analyzeCurrentJam() {
            try {
                const analysis = `
                    <div style="background: rgba(0,255,0,0.1); padding: 10px; border-radius: 5px; margin: 10px 0;">
                        📊 <strong>Jam Analysis:</strong><br>
                        Genre: ${genres[currentGenre].name}<br>
                        BPM: ${genres[currentGenre].bpm}<br>
                        Key: ${genres[currentGenre].key}<br>
                        Recorded Tracks: ${recordedTracks.length}<br>
                        Active UAD Plugins: ${Object.values(uadPlugins).filter(p => p.value > 0).length}<br>
                        Recommendation: ${recordedTracks.length < 3 ? 'Add more layers' : 'Focus on mixing'}
                    </div>
                `;
                
                const suggestionsDiv = document.getElementById('aiSuggestions');
                if (suggestionsDiv) {
                    suggestionsDiv.innerHTML = analysis;
                }
                addLog('ai', 'ANALYSIS', true, 'Jam analyzed');
            } catch (error) {
                addLog('ai', 'ANALYSIS', false, error.message);
            }
        }
        
        // Core System Functions (keeping all original working functions)
        function connectVideo() {
            console.log("connectVideo called");
            addLog('video', 'CONNECT_START', true, 'Attempting video connection');
            
            navigator.mediaDevices.getUserMedia({ video: true, audio: true })
                .then(stream => {
                    addLog('video', 'CONNECT', true, 'Camera connected successfully');
                    updateStatus('connection', 'ONLINE');
                })
                .catch(error => {
                    addLog('video', 'CONNECT', false, error.message);
                });
        }
        
        function toggleSpeech() {
            console.log("toggleSpeech called");
            addLog('speech', 'TOGGLE', true, 'Speech control toggled');
        }
        
        function populateInstruments(instruments) {
            console.log("populateInstruments called");
            try {
                const grid = document.getElementById('instrumentGrid');
                if (!grid) {
                    addLog('instruments', 'POPULATE', false, 'Instrument grid not found');
                    return;
                }
                
                grid.innerHTML = '';
                
                instruments.forEach((instrument, index) => {
                    const pad = document.createElement('button');
                    pad.className = 'instrument-pad';
                    pad.textContent = instrument;
                    pad.onclick = function() { playInstrument(index, instrument); };
                    grid.appendChild(pad);
                });
                
                addLog('instruments', 'POPULATE', true, `${instruments.length} instruments loaded`);
            } catch (error) {
                addLog('instruments', 'POPULATE', false, error.message);
            }
        }
        
        function loadLoops() {
            console.log("loadLoops called");
            populateLoops();
            addLog('garageband', 'LOAD_LOOPS', true, `Loaded ${currentGenre} loops`);
        }
        
        function populateLoops() {
            try {
                const browser = document.getElementById('loopBrowser');
                if (!browser) return;
                
                browser.innerHTML = '';
                
                const loops = appleLoops[currentGenre] || appleLoops['standard'];
                
                loops.forEach((loop, index) => {
                    const loopItem = document.createElement('button');
                    loopItem.className = 'control-btn';
                    loopItem.textContent = loop;
                    loopItem.style.padding = '10px';
                    loopItem.style.fontSize = '0.8em';
                    loopItem.onclick = function() { playLoop(loop); };
                    browser.appendChild(loopItem);
                });
                
                addLog('garageband', 'POPULATE_LOOPS', true, `${loops.length} loops loaded`);
            } catch (error) {
                addLog('garageband', 'POPULATE_LOOPS', false, error.message);
            }
        }
        
        function playLoop(loopName) {
            console.log("playLoop called:", loopName);
            
            if (!audioContext) {
                addLog('garageband', 'PLAY_LOOP', false, 'Audio not connected');
                return;
            }
            
            try {
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                let frequency = 200 + Math.random() * 100;
                let waveform = 'sawtooth';
                
                // Genre-specific loop characteristics
                switch (currentGenre) {
                    case 'motown':
                        frequency = 150;
                        waveform = 'sine';
                        break;
                    case 'reggae':
                        frequency = 100;
                        waveform = 'square';
                        break;
                    case 'indian':
                        frequency = 300;
                        waveform = 'triangle';
                        break;
                    case 'african':
                        frequency = 120;
                        waveform = 'triangle';
                        break;
                    case 'psychedelic':
                        frequency = 250;
                        waveform = 'sawtooth';
                        break;
                }
                
                oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
                oscillator.type = waveform;
                
                // Route through UAD plugins
                let currentNode = oscillator;
                Object.values(uadPlugins).forEach(plugin => {
                    if (plugin.node && !plugin.bypass && plugin.value > 0) {
                        currentNode.connect(plugin.node);
                        currentNode = plugin.node;
                    }
                });
                
                currentNode.connect(gainNode);
                gainNode.connect(masterGain);
                gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 1.0);
                
                oscillator.start();
                oscillator.stop(audioContext.currentTime + 1.0);
                
                addLog('garageband', 'PLAY_LOOP', true, loopName);
            } catch (error) {
                addLog('garageband', 'PLAY_LOOP', false, error.message);
            }
        }
        
        function openPiano() {
            console.log("openPiano called");
            addLog('garageband', 'PIANO_ROLL', true, 'Piano roll opened');
            alert('Piano Roll: Use QWERTY keys as piano!\nQ=C, W=C#, E=D, R=D#, T=E, Y=F, U=F#, I=G, O=G#, P=A\n\nAdditional shortcuts:\n0-7: Play instruments\nG: Load loops\nU: Load UAD\nJ: Ultimate jam\nM: Motown jam\nESC: Emergency stop');
        }
        
        function playAll() {
            console.log("playAll called");
            addLog('garageband', 'PLAY_ALL', true, 'Playing arrangement');
            for (let i = 0; i < 4; i++) {
                setTimeout(() => {
                    playLoop(`Track ${i + 1}`);
                }, i * 500);
            }
        }
        
        function loadUAD() {
            console.log("loadUAD called");
            populateUAD();
            addLog('uad', 'LOAD_PRESETS', true, `${currentGenre} UAD preset loaded`);
        }
        
        function populateUAD() {
            try {
                const rack = document.getElementById('uadRack');
                if (!rack) return;
                
                rack.innerHTML = '';
                
                Object.entries(uadPlugins).forEach(([plugin, config]) => {
                    const pluginDiv = document.createElement('div');
                    pluginDiv.style.background = config.bypass ? 'linear-gradient(45deg, #666, #333)' : 'linear-gradient(45deg, #333, #666)';
                    pluginDiv.style.border = config.bypass ? '2px solid #666' : '2px solid #ff6600';
                    pluginDiv.style.borderRadius = '10px';
                    pluginDiv.style.padding = '10px';
                    pluginDiv.style.textAlign = 'center';
                    pluginDiv.style.cursor = 'pointer';
                    pluginDiv.style.opacity = config.bypass ? '0.5' : '1';
                    pluginDiv.innerHTML = `
                        <div style="font-weight: bold; font-size: 0.8em;">${plugin}</div>
                        <div style="font-size: 0.7em; color: #ccc;">${config.name}</div>
                        <div style="font-size: 0.7em; color: ${config.bypass ? '#666' : '#00ff00'};">${config.value}%</div>
                        <div style="font-size: 0.6em; color: #999;">${config.bypass ? 'BYPASSED' : 'ACTIVE'}</div>
                    `;
                    pluginDiv.onclick = function() { toggleUAD(plugin); };
                    pluginDiv.oncontextmenu = function(e) { 
                        e.preventDefault(); 
                        bypassUAD(plugin); 
                    };
                    rack.appendChild(pluginDiv);
                });
                
                addLog('uad', 'POPULATE_RACK', true, `${Object.keys(uadPlugins).length} plugins loaded`);
            } catch (error) {
                addLog('uad', 'POPULATE_RACK', false, error.message);
            }
        }
        
        function resetUAD() {
            console.log("resetUAD called");
            Object.entries(uadPlugins).forEach(([id, config]) => {
                config.value = 0;
                config.bypass = false;
                if (config.node) {
                    switch (config.type) {
                        case 'compressor':
                            config.node.threshold.setValueAtTime(-50, audioContext.currentTime);
                            break;
                        case 'reverb':
                            if (config.node.gain) {
                                config.node.gain.setValueAtTime(0.5, audioContext.currentTime);
                            }
                            break;
                        case 'delay':
                            config.node.delayTime.setValueAtTime(0.3, audioContext.currentTime);
                            break;
                        case 'eq':
                            config.node.gain.setValueAtTime(0, audioContext.currentTime);
                            break;
                    }
                }
            });
            populateUAD();
            addLog('uad', 'RESET', true, 'All UAD plugins reset');
        }
        
        // Enhanced Jam Modes
        function ultimateJam() {
            console.log("ultimateJam called");
            try {
                const genreKeys = Object.keys(genres);
                const randomGenre = genreKeys[Math.floor(Math.random() * genreKeys.length)];
                changeGenre(randomGenre);
                
                // Load appropriate UAD preset
                loadUAD();
                
                setTimeout(() => {
                    const instruments = document.querySelectorAll('.instrument-pad');
                    if (instruments.length > 0) {
                        const randomInstrument = Math.floor(Math.random() * instruments.length);
                        instruments[randomInstrument].click();
                        
                        // Layer additional instruments
                        setTimeout(() => {
                            const secondInstrument = Math.floor(Math.random() * instruments.length);
                            if (secondInstrument !== randomInstrument) {
                                instruments[secondInstrument].click();
                            }
                        }, 1000);
                    }
                }, 1000);
                
                addLog('jam', 'ULTIMATE_START', true, `Ultimate jam in ${randomGenre}`);
            } catch (error) {
                addLog('jam', 'ULTIMATE_START', false, error.message);
            }
        }
        
        function motownJam() {
            console.log("motownJam called");
            try {
                changeGenre('motown');
                loadUAD();
                
                // Activate specific UAD plugins for Motown sound
                uadPlugins['LA-2A'].value = 75;
                uadPlugins['Lexicon 224'].value = 50;
                populateUAD();
                
                setTimeout(() => {
                    const instruments = document.querySelectorAll('.instrument-pad');
                    if (instruments[0]) instruments[0].click(); // Jamerson Bass
                    setTimeout(() => {
                        if (instruments[1]) instruments[1].click(); // Benny Drums
                        setTimeout(() => {
                            if (instruments[3]) instruments[3].click(); // Van Dyke Keys
                        }, 250);
                    }, 500);
                }, 1000);
                
                addLog('jam', 'MOTOWN_START', true, 'Motown jam with Funk Brothers');
            } catch (error) {
                addLog('jam', 'MOTOWN_START', false, error.message);
            }
        }
        
        function wreckingJam() {
            console.log("wreckingJam called");
            try {
                changeGenre('wreckingCrew');
                loadUAD();
                
                // Activate specific UAD plugins for Wall of Sound
                uadPlugins['1176'].value = 100;
                uadPlugins['Lexicon 224'].value = 75;
                uadPlugins['Pultec'].value = 50;
                populateUAD();
                
                setTimeout(() => {
                    const instruments = document.querySelectorAll('.instrument-pad');
                    if (instruments[0]) instruments[0].click(); // Kaye Bass
                    setTimeout(() => {
                        if (instruments[1]) instruments[1].click(); // Blaine Drums
                        setTimeout(() => {
                            if (instruments[2]) instruments[2].click(); // Tedesco Guitar
                        }, 250);
                    }, 500);
                }, 1000);
                
                addLog('jam', 'WRECKING_START', true, 'Wrecking Crew jam');
            } catch (error) {
                addLog('jam', 'WRECKING_START', false, error.message);
            }
        }
        
        function psychedelicJam() {
            console.log("psychedelicJam called");
            try {
                changeGenre('psychedelic');
                loadUAD();
                
                // Activate psychedelic effects
                uadPlugins['Galaxy'].value = 75;
                uadPlugins['Brigade'].value = 50;
                uadPlugins['LA-610'].value = 25;
                populateUAD();
                
                setTimeout(() => {
                    const instruments = document.querySelectorAll('.instrument-pad');
                    if (instruments[5]) instruments[5].click(); // Sitar
                    setTimeout(() => {
                        if (instruments[1]) instruments[1].click(); // Wah Guitar
                        setTimeout(() => {
                            if (instruments[4]) instruments[4].click(); // Mellotron
                        }, 500);
                    }, 1000);
                }, 1000);
                
                addLog('jam', 'PSYCHEDELIC_START', true, 'Psychedelic space jam');
            } catch (error) {
                addLog('jam', 'PSYCHEDELIC_START', false, error.message);
            }
        }
        
        function stopJams() {
            console.log("stopJams called");
            try {
                // Stop all audio
                if (audioContext) {
                    const oscillators = audioContext.createOscillator();
                    // Note: Can't actually stop all oscillators, but we can reset the system
                }
                
                // Reset all UAD plugins
                resetUAD();
                
                // Reset genre to standard
                changeGenre('standard');
                
                addLog('jam', 'STOP_ALL', true, 'All jams stopped and system reset');
            } catch (error) {
                addLog('jam', 'STOP_ALL', false, error.message);
            }
        }
        
        // Testing System
        function runSystemTest() {
            console.log("runSystemTest called");
            
            if (isTesting) {
                addLog('system', 'TEST_BLOCKED', false, 'Test already in progress');
                return;
            }

            try {
                isTesting = true;
                
                const controls = document.getElementById('heuristicControls');
                const complete = document.getElementById('testComplete');
                if (controls) controls.style.display = 'none';
                if (complete) complete.style.display = 'none';
                
                addLog('system', 'FULL_TEST_START', true, 'Running comprehensive system test');

                const modules = ['connection', 'genre', 'garageBand', 'uad', 'recording', 'mixer', 'collaboration', 'ai', 'jam'];
                let allPassed = true;

                modules.forEach((module, index) => {
                    setTimeout(() => {
                        try {
                            const moduleElement = document.getElementById(module + 'Module');
                            let result = moduleElement && moduleElement.offsetParent !== null;
                            
                            // Additional specific tests
                            if (module === 'connection') result = result && document.getElementById('connectionModule') !== null;
                            if (module === 'mixer') result = result && document.getElementById('mixerModule') !== null;
                            if (module === 'recording') result = result && typeof MediaRecorder !== 'undefined';
                            if (module === 'uad') result = result && Object.keys(uadPlugins).length > 0;
                            
                            if (!result) allPassed = false;

                            updateStatus(module, result ? 'TESTED ✓' : 'ERROR ✗');
                            addLog(module, 'INTEGRITY', result, result ? 'Module OK' : 'Module failed');

                            if (index === modules.length - 1) {
                                setTimeout(() => {
                                    addLog('system', 'FULL_TEST_COMPLETE', allPassed, 
                                        allPassed ? 'All modules passed' : 'Some modules failed');
                                    
                                    modules.forEach(mod => {
                                        setTimeout(() => updateStatus(mod, 'READY'), 1000);
                                    });

                                    isTesting = false;
                                    addLog('system', 'UI_UNLOCK', true, 'Test complete');
                                    
                                    if (complete) complete.style.display = 'block';
                                }, 500);
                            }
                        } catch (error) {
                            addLog(module, 'TEST_ERROR', false, error.message);
                            allPassed = false;
                        }
                    }, index * 300);
                });
            } catch (error) {
                addLog('system', 'FULL_TEST_ERROR', false, error.message);
                isTesting = false;
            }
        }
        
        function testConnection() {
            const module = document.getElementById('connectionModule');
            const result = module && module.offsetParent !== null;
            addLog('connection', 'TEST', result, 'Module integrity check');
            updateStatus('connection', result ? 'TESTED ✓' : 'ERROR ✗');
            setTimeout(() => updateStatus('connection', audioContext ? 'ONLINE' : 'OFFLINE'), 2000);
        }
        
        function testGarageBand() {
            const module = document.getElementById('garageBandModule');
            const result = module && module.offsetParent !== null;
            addLog('garageband', 'TEST', result, 'Module integrity check');
            updateStatus('garageBand', result ? 'TESTED ✓' : 'ERROR ✗');
            setTimeout(() => updateStatus('garageBand', 'READY'), 2000);
        }
        
        function testUAD() {
            const module = document.getElementById('uadModule');
            const result = module && module.offsetParent !== null;
            addLog('uad', 'TEST', result, 'Module integrity check');
            updateStatus('uad', result ? 'TESTED ✓' : 'ERROR ✗');
            setTimeout(() => updateStatus('uad', 'READY'), 2000);
        }
        
        function testRecording() {
            const module = document.getElementById('recordingModule');
            const result = module && module.offsetParent !== null && typeof MediaRecorder !== 'undefined';
            addLog('recording', 'TEST', result, 'Module and MediaRecorder check');
            updateStatus('recording', result ? 'TESTED ✓' : 'ERROR ✗');
            setTimeout(() => updateStatus('recording', 'READY'), 2000);
        }
        
        function testMixer() {
            const module = document.getElementById('mixerModule');
            const result = module && module.offsetParent !== null;
            addLog('mixer', 'TEST', result, 'Module integrity check');
            updateStatus('mixer', result ? 'TESTED ✓' : 'ERROR ✗');
            setTimeout(() => updateStatus('mixer', 'READY'), 2000);
        }
        
        function testCollaboration() {
            const module = document.getElementById('collaborationModule');
            const result = module && module.offsetParent !== null;
            addLog('collaboration', 'TEST', result, 'Module integrity check');
            updateStatus('collaboration', result ? 'TESTED ✓' : 'ERROR ✗');
            setTimeout(() => updateStatus('collaboration', 'READY'), 2000);
        }
        
        function testAI() {
            const module = document.getElementById('aiModule');
            const result = module && module.offsetParent !== null;
            addLog('ai', 'TEST', result, 'AI Assistant module check');
            updateStatus('ai', result ? 'TESTED ✓' : 'ERROR ✗');
            setTimeout(() => updateStatus('ai', 'READY'), 2000);
        }
        
        // Utility Functions
        function clearLog() {
            console.log("clearLog called");
            try {
                const logElement = document.getElementById('heuristicLog');
                if (logElement) {
                    logElement.innerHTML = '';
                    addLog('system', 'LOG_CLEARED', true, 'Log cleared successfully');
                }
            } catch (error) {
                console.error('Clear log error:', error);
            }
        }
        
        function closeTest() {
            console.log("closeTest called");
            const controls = document.getElementById('heuristicControls');
            const complete = document.getElementById('testComplete');
            if (complete) complete.style.display = 'none';
            if (controls) controls.style.display = 'block';
            addLog('system', 'TEST_CLOSED', true, 'Test results closed');
        }
        
        function togglePanel() {
            console.log("togglePanel called");
            const panel = document.getElementById('heuristicPanel');
            if (panel) {
                panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
                addLog('panel', 'TOGGLE', true, 'Panel toggled');
            }
        }
        
        function updateStatus(moduleName, status) {
            try {
                const statusElement = document.getElementById(moduleName + 'Status');
                if (statusElement) {
                    statusElement.textContent = status;
                    
                    if (status.includes('ERROR') || status.includes('✗')) {
                        statusElement.style.background = '#ff0000';
                    } else if (status.includes('✓') || status === 'ACTIVE') {
                        statusElement.style.background = '#00ff00';
                    } else if (status === 'ONLINE') {
                        statusElement.style.background = '#00aaff';
                    } else if (status === 'RECORDING') {
                        statusElement.style.background = '#ff0000';
                        statusElement.style.animation = 'blink 1s infinite';
                    } else {
                        statusElement.style.background = '#00ff00';
                        statusElement.style.animation = 'none';
                    }
                }
            } catch (error) {
                console.error('Error updating module status:', error);
            }
        }
        
        function emergencyStop() {
            console.log("emergencyStop called");
            try {
                // Stop all recordings
                stopRecording();
                
                // Mute all tracks
                tracks.forEach(track => {
                    if (track.gainNode) {
                        track.gainNode.gain.setValueAtTime(0, audioContext.currentTime);
                    }
                });
                
                // Reset to standard genre
                changeGenre('standard');
                
                // Reset all UAD plugins
                resetUAD();
                
                // Stop collaboration
                collaborationActive = false;
                
                addLog('emergency', 'STOP', true, 'Emergency stop executed - all systems reset');
                
                document.body.style.background = '#ff0000';
                setTimeout(() => {
                    document.body.style.background = '';
                }, 200);
            } catch (error) {
                addLog('emergency', 'STOP', false, error.message);
            }
        }
        
        // Enhanced Keyboard Controls
        document.addEventListener('keydown', function(event) {
            try {
                const pianoKeys = {
                    'q': 261.63, 'w': 277.18, 'e': 293.66, 'r': 311.13, 't': 329.63,
                    'y': 349.23, 'u': 369.99, 'i': 392.00, 'o': 415.30, 'p': 440.00
                };
                
                if (pianoKeys[event.key.toLowerCase()] && audioContext) {
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();
                    
                    let frequency = pianoKeys[event.key.toLowerCase()];
                    
                    // Apply microtonal tuning for Indian genre
                    if (currentGenre === 'indian' && genres.indian.tuning) {
                        const keyIndex = Object.keys(pianoKeys).indexOf(event.key.toLowerCase());
                        if (keyIndex !== -1 && keyIndex < genres.indian.tuning.length) {
                            frequency = genres.indian.tuning[keyIndex];
                        }
                    }
                    
                    oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
                    oscillator.type = currentGenre === 'psychedelic' ? 'sawtooth' : 'sine';
                    
                    gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
                    
                    // Route through UAD plugins
                    let currentNode = oscillator;
                    Object.values(uadPlugins).forEach(plugin => {
                        if (plugin.node && !plugin.bypass && plugin.value > 0) {
                            currentNode.connect(plugin.node);
                            currentNode = plugin.node;
                        }
                    });
                    
                    currentNode.connect(gainNode);
                    gainNode.connect(masterGain);
                    
                    oscillator.start();
                    oscillator.stop(audioContext.currentTime + 0.5);
                    
                    addLog('piano', 'KEY_PRESS', true, `Piano key: ${event.key.toUpperCase()}`);
                    return;
                }
                
                // Enhanced keyboard shortcuts
                switch(event.key) {
                    case ' ': // Spacebar
                        event.preventDefault();
                        playAll();
                        break;
                    case 'g':
                    case 'G':
                        if (!pianoKeys[event.key.toLowerCase()]) {
                            loadLoops();
                        }
                        break;
                    case 'u':
                    case 'U':
                        if (!pianoKeys[event.key.toLowerCase()]) {
                            loadUAD();
                        }
                        break;
                    case 'j':
                    case 'J':
                        ultimateJam();
                        break;
                    case 'm':
                    case 'M':
                        motownJam();
                        break;
                    case 'w':
                    case 'W':
                        if (!pianoKeys[event.key.toLowerCase()]) {
                            wreckingJam();
                        }
                        break;
                    case 'z':
                    case 'Z':
                        psychedelicJam();
                        break;
                    case 'c':
                    case 'C':
                        if (event.ctrlKey) {
                            startCollaboration();
                        }
                        break;
                    case 'a':
                    case 'A':
                        if (event.ctrlKey) {
                            getAISuggestion();
                        }
                        break;
                    case 'Escape':
                        emergencyStop();
                        break;
                    default:
                        if (event.key >= '0' && event.key <= '7') {
                            const index = parseInt(event.key);
                            const instruments = document.querySelectorAll('.instrument-pad');
                            if (instruments[index]) {
                                instruments[index].click();
                            }
                        }
                }
            } catch (error) {
                addLog('keyboard', 'ERROR', false, error.message);
            }
        });
        
        // Initialize everything when page loads
        document.addEventListener('DOMContentLoaded', function() {
            try {
                addLog('system', 'STARTUP', true, 'Ultimate Cosmic Studio COMPLETE EDITION starting...');
                
                populateInstruments(genres.standard.instruments);
                addLog('instruments', 'LOADED', true, 'Standard instruments populated');
                
                populateLoops();
                addLog('loops', 'LOADED', true, 'Apple loops populated');
                
                populateUAD();
                addLog('uad', 'LOADED', true, 'UAD plugins populated');
                
                initAIAssistant();
                addLog('ai', 'LOADED', true, 'AI Assistant initialized');
                
                addLog('system', 'INITIALIZATION', true, 'Ultimate Cosmic Studio COMPLETE EDITION ready!');
                addLog('system', 'INSTRUCTIONS', true, 'Click "Connect Audio" then test all features');
                
                setTimeout(() => {
                    addLog('system', 'AUTO_TEST', true, 'Running automatic system validation...');
                    runSystemTest();
                }, 2000);
                
            } catch (error) {
                addLog('system', 'INITIALIZATION', false, `Startup failed: ${error.message}`);
                showError(`Initialization failed: ${error.message}`);
            }
        });
        
        console.log("✅ Ultimate Cosmic Studio COMPLETE EDITION - All functions loaded successfully!");
        addLog('debug', 'FUNCTIONS_LOADED', true, 'All enhanced functions properly defined');
    </script>

    <!-- Error Display -->
    <div class="error-display" id="errorDisplay">
        <h3>🚨 SYSTEM ERROR DETECTED 🚨</h3>
        <div id="errorMessage"></div>
        <button onclick="closeErrorDisplay()" style="margin-top: 10px; padding: 10px; background: #333; color: white; border: none; border-radius: 5px; cursor: pointer;">Close Error</button>
    </div>

    <div class="cosmic-container">
        <header class="header">
            <h1>🌌 ULTIMATE COSMIC STUDIO 🌌</h1>
            <p>COMPLETE EDITION - Professional Music Production Platform</p>
        </header>
        
        <!-- Heuristic Testing Panel -->
        <div class="heuristic-panel" id="heuristicPanel">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                <div style="font-weight: bold;">🧪 SYSTEM DIAGNOSTICS</div>
                <button onclick="togglePanel()" style="background: #ff0000; border: none; color: #fff; width: 20px; height: 20px; border-radius: 50%; cursor: pointer; font-size: 12px;">✕</button>
            </div>
            <div id="heuristicLog"></div>
            <div id="heuristicControls">
                <button class="control-btn" onclick="runSystemTest()" style="width: 100%; margin-top: 10px;">FULL SYSTEM TEST</button>
                <button class="control-btn" onclick="clearLog()" style="width: 100%; margin-top: 5px; background: #666;">CLEAR LOG</button>
            </div>
            <div id="testComplete" style="display: none;">
                <button class="control-btn" onclick="closeTest()" style="width: 100%; margin-top: 10px; background: #00aa00;">✓ TEST COMPLETE</button>
            </div>
        </div>
        
        <!-- Connection Module -->
        <div class="module" id="connectionModule">
            <div class="module-header">
                <h2 class="module-title">🔌 Connection Hub</h2>
                <span class="module-status" id="connectionStatus">OFFLINE</span>
            </div>
            <div class="control-grid">
                <button class="control-btn" onclick="connectAudio()">Connect Audio</button>
                <button class="control-btn" onclick="connectVideo()">Connect Video</button>
                <button class="control-btn" onclick="toggleSpeech()">Speech Control</button>
                <button class="control-btn" onclick="testConnection()">Test Module</button>
            </div>
            <div class="volume-meter">
                <div class="volume-bar" id="volumeBar"></div>
            </div>
            <canvas id="spectrumAnalyzer" class="spectrum-analyzer"></canvas>
        </div>
        
        <!-- World Music Genre Module -->
        <div class="module" id="genreModule">
            <div class="module-header">
                <h2 class="module-title">🌍 World Music Genres</h2>
                <span class="module-status" id="genreStatus">READY</span>
            </div>
            <select class="genre-selector" id="genreSelect" onchange="changeGenre(this.value)">
                <option value="standard">Standard</option>
                <option value="motown">Motown (Funk Brothers)</option>
                <option value="wreckingCrew">Wrecking Crew (LA Studio)</option>
                <option value="reggae">Reggae</option>
                <option value="psychedelic">Psychedelic</option>
                <option value="indian">Indian Classical</option>
                <option value="african">African Polyrhythms</option>
            </select>
            <div id="genreInfo" style="background: rgba(0,0,0,0.3); padding: 10px; border-radius: 5px; margin: 10px 0; font-size: 0.8em;"></div>
            <div class="instrument-grid" id="instrumentGrid"></div>
        </div>
        
        <!-- GarageBand Module -->
        <div class="module" id="garageBandModule">
            <div class="module-header">
                <h2 class="module-title">🎹 GarageBand Studio</h2>
                <span class="module-status" id="garageBandStatus">READY</span>
            </div>
            <div class="control-grid">
                <button class="control-btn" onclick="loadLoops()">Load Apple Loops</button>
                <button class="control-btn" onclick="openPiano()">Piano Roll</button>
                <button class="control-btn" onclick="playAll()">Play Arrangement</button>
                <button class="control-btn" onclick="testGarageBand()">Test Module</button>
            </div>
            <div id="loopBrowser" style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px; margin: 20px 0;"></div>
        </div>
        
        <!-- UAD Module -->
        <div class="module" id="uadModule">
            <div class="module-header">
                <h2 class="module-title">🔊 UAD Plugins Rack</h2>
                <span class="module-status" id="uadStatus">READY</span>
            </div>
            <div class="control-grid">
                <button class="control-btn" onclick="loadUAD()">Load UAD Presets</button>
                <button class="control-btn" onclick="resetUAD()">Reset Plugins</button>
                <button class="control-btn" onclick="bypassUAD()">Bypass All</button>
                <button class="control-btn" onclick="testUAD()">Test Module</button>
            </div>
            <div id="uadRack" style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px; margin: 20px 0;"></div>
        </div>
        
        <!-- Recording Module -->
        <div class="module" id="recordingModule">
            <div class="module-header">
                <h2 class="module-title">🎙️ Multitrack Recording</h2>
                <span class="module-status" id="recordingStatus">READY</span>
            </div>
            <div class="control-grid">
                <button class="control-btn" onclick="startRecording()">Record Track</button>
                <button class="control-btn" onclick="stopRecording()">Stop Recording</button>
                <button class="control-btn" onclick="exportSession()">Export Session</button>
                <button class="control-btn" onclick="testRecording()">Test Module</button>
            </div>
            <canvas id="waveformTimeline" width="1000" height="200" class="waveform-timeline"></canvas>
            <div id="trackList" style="background: rgba(0,0,0,0.3); padding: 10px; border-radius: 5px; margin: 10px 0; max-height: 150px; overflow-y: auto;"></div>
        </div>
        
        <!-- Mixer Module -->
        <div class="module" id="mixerModule">
            <div class="module-header">
                <h2 class="module-title">🎚️ Professional Mixing Console</h2>
                <span class="module-status" id="mixerStatus">READY</span>
            </div>
            <div id="mixerTracks" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 10px; margin: 20px 0;"></div>
            <div class="control-grid">
                <button class="control-btn" onclick="addTrack()">Add Track</button>
                <button class="control-btn" onclick="applyMasterProcessing()">Master Processing</button>
                <button class="control-btn" onclick="testMixer()">Test Module</button>
            </div>
        </div>
        
        <!-- Collaboration Module -->
        <div class="module" id="collaborationModule">
            <div class="module-header">
                <h2 class="module-title">🤝 Real-Time Collaboration</h2>
                <span class="module-status" id="collaborationStatus">READY</span>
            </div>
            <div class="control-grid">
                <button class="control-btn" onclick="startCollaboration()">Start Session</button>
                <button class="control-btn" onclick="sendChatMessage()">Send Message</button>
                <button class="control-btn" onclick="testCollaboration()">Test Module</button>
            </div>
            <div id="chatPanel" class="chat-panel"></div>
        </div>
        
        <!-- AI Assistant Module -->
        <div class="module" id="aiModule">
            <div class="module-header">
                <h2 class="module-title">🤖 AI Music Assistant</h2>
                <span class="module-status" id="aiStatus">READY</span>
            </div>
            <div class="ai-assistant" id="aiAssistant"></div>
            <div class="control-grid">
                <button class="control-btn" onclick="getAISuggestion()">Get AI Suggestion</button>
                <button class="control-btn" onclick="analyzeCurrentJam()">Analyze Jam</button>
                <button class="control-btn" onclick="testAI()">Test Module</button>
            </div>
        </div>
        
        <!-- Enhanced Jam Mode Module -->
        <div class="module" id="jamModule">
            <div class="module-header">
                <h2 class="module-title">🎸 Ultimate Jam Modes</h2>
                <span class="module-status" id="jamStatus">READY</span>
            </div>
            <div class="control-grid">
                <button class="control-btn" onclick="ultimateJam()">Ultimate Jam</button>
                <button class="control-btn" onclick="motownJam()">Motown Jam</button>
                <button class="control-btn" onclick="wreckingJam()">Wrecking Crew</button>
                <button class="control-btn" onclick="psychedelicJam()">Psychedelic Jam</button>
                <button class="control-btn" onclick="stopJams()">Stop All Jams</button>
            </div>
        </div>
        
        <!-- Session Management -->
        <div class="module">
            <div class="module-header">
                <h2 class="module-title">💾 Session Management</h2>
                <span class="module-status">READY</span>
            </div>
            <div class="session-manager">
                <button class="control-btn" onclick="saveSession()">Save Session</button>
                <button class="control-btn" onclick="loadSession()">Load Session</button>
                <button class="control-btn" onclick="newSession()">New Session</button>
            </div>
        </div>
        
        <!-- Keyboard Shortcuts Help -->
        <div class="module">
            <div class="module-header">
                <h2 class="module-title">⌨️ Keyboard Shortcuts</h2>
                <span class="module-status">INFO</span>
            </div>
            <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 20px; font-size: 0.8em;">
                <div>
                    <strong>Piano Keys:</strong><br>
                    Q-P: Play piano notes<br><br>
                    <strong>Instruments:</strong><br>
                    0-7: Play instruments<br><br>
                    <strong>System:</strong><br>
                    G: Load loops<br>
                    U: Load UAD<br>
                    Space: Play all
                </div>
                <div>
                    <strong>Jam Modes:</strong><br>
                    J: Ultimate jam<br>
                    M: Motown jam<br>
                    W: Wrecking Crew<br>
                    Z: Psychedelic jam<br><br>
                    <strong>Special:</strong><br>
                    Ctrl+C: Collaboration<br>
                    Ctrl+A: AI suggestion<br>
                    ESC: Emergency stop
                </div>
            </div>
        </div>
    </div>
    
    <div class="emergency-stop" onclick="emergencyStop()" title="Emergency Stop - Resets All Systems">STOP</div>
    
    <script>
        // Additional Session Management Functions
        function saveSession() {
            try {
                const sessionData = {
                    name: `Cosmic Session ${Date.now()}`,
                    genre: currentGenre,
                    tracks: recordedTracks.length,
                    uadSettings: Object.fromEntries(
                        Object.entries(uadPlugins).map(([key, val]) => [key, {value: val.value, bypass: val.bypass}])
                    ),
                    mixerSettings: tracks.map(track => ({
                        volume: track.volume,
                        pan: track.pan,
                        eq: track.eq,
                        muted: track.muted,
                        soloed: track.soloed
                    })),
                    timestamp: Date.now(),
                    version: 'COMPLETE_EDITION_1.0'
                };
                
                const blob = new Blob([JSON.stringify(sessionData, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `cosmic-session-${Date.now()}.json`;
                a.click();
                URL.revokeObjectURL(url);
                
                addLog('session', 'SAVE', true, `Session saved: ${sessionData.name}`);
            } catch (error) {
                addLog('session', 'SAVE', false, error.message);
                showError(`Session save failed: ${error.message}`);
            }
        }
        
        function loadSession() {
            try {
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = '.json';
                input.onchange = function(event) {
                    const file = event.target.files[0];
                    if (file) {
                        const reader = new FileReader();
                        reader.onload = function(e) {
                            try {
                                const sessionData = JSON.parse(e.target.result);
                                
                                // Restore genre
                                changeGenre(sessionData.genre);
                                
                                // Restore UAD settings
                                if (sessionData.uadSettings) {
                                    Object.entries(sessionData.uadSettings).forEach(([plugin, settings]) => {
                                        if (uadPlugins[plugin]) {
                                            uadPlugins[plugin].value = settings.value;
                                            uadPlugins[plugin].bypass = settings.bypass;
                                        }
                                    });
                                    populateUAD();
                                }
                                
                                // Restore mixer settings
                                if (sessionData.mixerSettings && tracks.length >= sessionData.mixerSettings.length) {
                                    sessionData.mixerSettings.forEach((settings, index) => {
                                        if (tracks[index]) {
                                            tracks[index].volume = settings.volume;
                                            tracks[index].pan = settings.pan;
                                            tracks[index].eq = settings.eq;
                                            tracks[index].muted = settings.muted;
                                            tracks[index].soloed = settings.soloed;
                                        }
                                    });
                                }
                                
                                addLog('session', 'LOAD', true, `Session loaded: ${sessionData.name}`);
                            } catch (error) {
                                addLog('session', 'LOAD', false, `Invalid session file: ${error.message}`);
                                showError(`Session load failed: ${error.message}`);
                            }
                        };
                        reader.readAsText(file);
                    }
                };
                input.click();
            } catch (error) {
                addLog('session', 'LOAD', false, error.message);
                showError(`Session load failed: ${error.message}`);
            }
        }
        
        function newSession() {
            try {
                // Reset everything to defaults
                changeGenre('standard');
                resetUAD();
                recordedTracks = [];
                drawWaveform();
                updateTrackList();
                
                // Reset mixer
                tracks.forEach(track => {
                    track.volume = 1;
                    track.pan = 0;
                    track.eq = 0;
                    track.muted = false;
                    track.soloed = false;
                    if (track.gainNode) track.gainNode.gain.setValueAtTime(1, audioContext.currentTime);
                    if (track.panNode) track.panNode.pan.setValueAtTime(0, audioContext.currentTime);
                    if (track.eqNode) track.eqNode.gain.setValueAtTime(0, audioContext.currentTime);
                });
                
                // Stop collaboration
                collaborationActive = false;
                const chatPanel = document.getElementById('chatPanel');
                if (chatPanel) chatPanel.innerHTML = '';
                
                addLog('session', 'NEW', true, 'New session created - all settings reset');
            } catch (error) {
                addLog('session', 'NEW', false, error.message);
                showError(`New session failed: ${error.message}`);
            }
        }
        
        // Performance monitoring
        setInterval(() => {
            if (audioContext && audioContext.state === 'running') {
                const performance = {
                    sampleRate: audioContext.sampleRate,
                    currentTime: Math.round(audioContext.currentTime * 100) / 100,
                    state: audioContext.state,
                    tracks: tracks.length,
                    recordings: recordedTracks.length
                };
                
                // Update performance display if it exists
                const perfDiv = document.getElementById('performanceInfo');
                if (perfDiv) {
                    perfDiv.innerHTML = `
                        Sample Rate: ${performance.sampleRate}Hz |
                        Time: ${performance.currentTime}s |
                        Tracks: ${performance.tracks} |
                        Recordings: ${performance.recordings}
                    `;
                }
            }
        }, 1000);
        
        console.log("🌌✨ Ultimate Cosmic Studio COMPLETE EDITION successfully initialized! ✨🌌");
        console.log("🎵 Ready for professional music production! 🎵");
    </script>
</body>
</html>
